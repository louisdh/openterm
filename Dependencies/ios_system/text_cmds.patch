diff -Naur text_cmds-99/cat/cat.c text_cmds/cat/cat.c
--- text_cmds-99/cat/cat.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/cat/cat.c	2018-01-10 11:31:02.000000000 +0100
@@ -55,7 +55,7 @@
 #endif
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <fcntl.h>
 #include <locale.h>
 #include <stdio.h>
@@ -63,9 +63,10 @@
 #include <string.h>
 #include <unistd.h>
 #include <stddef.h>
+#include "ios_error.h"
 
-int bflag, eflag, nflag, sflag, tflag, vflag;
-int rval;
+static int bflag, eflag, nflag, sflag, tflag, vflag;
+static int rval;
 const char *filename;
 
 static void usage(void);
@@ -78,11 +79,14 @@
 #endif
 
 int
-main(int argc, char *argv[])
+cat_main(int argc, char *argv[])
 {
 	int ch;
 
 	setlocale(LC_CTYPE, "");
+    // Initialize all flags
+    bflag = eflag = nflag = sflag = tflag = vflag = 0; rval = 0;
+    optind = 1; opterr = 1; optreset = 1;
 
 	while ((ch = getopt(argc, argv, "benstuv")) != -1)
 		switch (ch) {
@@ -116,8 +120,8 @@
 		scanfiles(argv, 1);
 	else
 		scanfiles(argv, 0);
-	if (fclose(stdout))
-		err(1, "stdout");
+	// if (fclose(stdout)) err(1, "stdout");
+    optarg = NULL; opterr = 0; optind = 0;
 	exit(rval);
 	/* NOTREACHED */
 }
@@ -152,7 +156,8 @@
 #endif
 		}
 		if (fd < 0) {
-			warn("%s", path);
+            fprintf(stderr, "cat: %s: %s\n", path, strerror(errno));
+            // warn("%s", path);
 			rval = 1;
 		} else if (cooked) {
 			if (fd == STDIN_FILENO)
@@ -226,12 +231,16 @@
 			break;
 	}
 	if (ferror(fp)) {
-		warn("%s", filename);
+        fprintf(stderr, "cat: %s: %s\n", filename, strerror(errno));
+        // warn("%s", filename);
 		rval = 1;
 		clearerr(fp);
 	}
-	if (ferror(stdout))
-		err(1, "stdout");
+    if (ferror(stdout)) {
+		// err(1, "stdout");
+        fprintf(stderr, "cat: stdout: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 }
 
 static void
@@ -241,24 +250,36 @@
 	ssize_t nr, nw;
 	static size_t bsize;
 	static char *buf = NULL;
-	struct stat sbuf;
+	// struct stat sbuf;
 
 	wfd = fileno(stdout);
 	if (buf == NULL) {
-		if (fstat(wfd, &sbuf))
-			err(1, "%s", filename);
-		bsize = MAX(sbuf.st_blksize, 1024);
-		if ((buf = malloc(bsize)) == NULL)
-			err(1, "buffer");
+        // if (fstat(wfd, &sbuf))
+			// err(1, "%s", filename);
+        bsize = 1024; // MAX(sbuf.st_blksize, 1024);
+        if ((buf = malloc(bsize)) == NULL) {
+            // err(1, "buffer");
+            fprintf(stderr, "cat: buffer: %s\n", strerror(errno));
+            pthread_exit(NULL);
+        }
 	}
 	while ((nr = read(rfd, buf, bsize)) > 0)
-		for (off = 0; nr; nr -= nw, off += nw)
-			if ((nw = write(wfd, buf + off, (size_t)nr)) < 0)
-				err(1, "stdout");
+        for (off = 0; nr; nr -= nw, off += nw) {
+            // We can't write to the fd of stdout, so we write to stdout
+            nw = 0; // number of bytes written
+            for (int i = 0; i < nr; i++) {
+                fputc(*(buf+off+nw), stdout);
+                nw += 1;
+            }
+			// if ((nw = write(wfd, buf + off, (size_t)nr)) < 0) err(1, "stdout");
+        }
 	if (nr < 0) {
-		warn("%s", filename);
+        fprintf(stderr, "cat: %s: %s\n", filename, strerror(errno));
+        // warn("%s", filename);
 		rval = 1;
 	}
+    free(buf);
+    buf = NULL;
 }
 
 #ifndef NO_UDOM_SUPPORT
@@ -298,11 +319,13 @@
 		switch(flags & O_ACCMODE) {
 		case O_RDONLY:
 			if (shutdown(fd, SHUT_WR) == -1)
-				warn(NULL);
+                fprintf(stderr, "cat: %s\n", strerror(errno));
+                // warn(NULL);
 			break;
 		case O_WRONLY:
 			if (shutdown(fd, SHUT_RD) == -1)
-				warn(NULL);
+                fprintf(stderr, "cat: %s\n", strerror(errno));
+				// warn(NULL);
 			break;
 		default:
 			break;
diff -Naur text_cmds-99/ed/buf.c text_cmds/ed/buf.c
--- text_cmds-99/ed/buf.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/buf.c	2018-01-10 11:31:02.000000000 +0100
@@ -33,6 +33,10 @@
 #include <sys/stat.h>
 
 #include "ed.h"
+// from ios_system:
+#include "ios_error.h"
+#include <pthread.h>
+#import <Foundation/Foundation.h>
 
 
 FILE *sfp;				/* scratch file pointer */
@@ -185,7 +189,7 @@
 
 extern int newline_added;
 
-char sfn[15] = "";				/* scratch file name */
+char sfn[PATH_MAX] = "";				/* scratch file name */
 
 /* open_sbuf: open scratch file */
 int
@@ -196,7 +200,10 @@
 
 	isbinary = newline_added = 0;
 	u = umask(077);
-	strcpy(sfn, "/tmp/ed.XXXXXX");
+    // getenv($HOME) + "/tmp/" or NSString * NSTemporaryDirectory(void);
+    // the latter, I guess.
+    sprintf(sfn, "%s/ed.XXXXXX", NSTemporaryDirectory().UTF8String);
+	// strcpy(sfn, "/tmp/ed.XXXXXX");
 	if ((fd = mkstemp(sfn)) == -1 ||
 	    (sfp = fdopen(fd, "w+")) == NULL) {
 		if (fd != -1)
@@ -237,7 +244,8 @@
 		fclose(sfp);
 		unlink(sfn);
 	}
-	exit(n);
+	// exit(n);
+    pthread_exit(NULL);
 }
 
 
diff -Naur text_cmds-99/ed/ed.h text_cmds/ed/ed.h
--- text_cmds-99/ed/ed.h	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/ed.h	2018-01-10 11:31:02.000000000 +0100
@@ -275,7 +275,7 @@
 extern long current_addr;
 extern const char *errmsg;
 extern long first_addr;
-extern int lineno;
+extern int ed_lineno;
 extern long second_addr;
 extern long u_addr_last;
 extern long u_current_addr;
diff -Naur text_cmds-99/ed/io.c text_cmds/ed/io.c
--- text_cmds-99/ed/io.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/io.c	2018-01-10 11:31:02.000000000 +0100
@@ -267,7 +267,7 @@
 			if (!(ibuf[i++] = c)) isbinary = 1;
 			if (c != '\n')
 				continue;
-			lineno++;
+			ed_lineno++;
 			ibuf[i] = '\0';
 			ibufp = ibuf;
 			return i;
diff -Naur text_cmds-99/ed/main.c text_cmds/ed/main.c
--- text_cmds-99/ed/main.c	2006-04-21 01:51:01.000000000 +0200
+++ text_cmds/ed/main.c	2018-01-10 11:31:02.000000000 +0100
@@ -59,13 +59,17 @@
 #include <pwd.h>
 #include <setjmp.h>
 
-#ifdef __APPLE__
-#include <get_compat.h>
-#else
+// #ifdef __APPLE__
+// #include <get_compat.h>
+// #else
 #define COMPAT_MODE(a,b) (1)
-#endif /* __APPLE__ */
+// #endif /* __APPLE__ */
 
 #include "ed.h"
+// from ios_system:
+#include "ios_error.h"
+#include <pthread.h>
+extern int ios_system(char* cmd);
 
 
 #ifdef _POSIX_SOURCE
@@ -100,18 +104,46 @@
 char old_filename[PATH_MAX + 1] = "";	/* default filename */
 long current_addr;		/* current address in editor buffer */
 long addr_last;			/* last address in editor buffer */
-int lineno;			/* script line number */
+int ed_lineno;			/* script line number */
 const char *prompt;		/* command-line prompt */
 const char *dps = "*";		/* default command-line prompt */
 
-const char usage[] = "usage: %s [-] [-sx] [-p string] [file]\n";
+const char ed_usage[] = "usage: %s [-] [-sx] [-p string] [file]\n";
 
 /* ed: line editor */
 int
-main(int argc, char *argv[])
+ed_main(int argc, char *argv[])
 {
 	int c, n;
 	long status = 0;
+    // iOS: init all flags and variables:
+    /* global flags */
+    des = 0;            /* if set, use crypt(3) for i/o */
+    garrulous = 0;        /* if set, print all error messages */
+    isbinary = 0;            /* if set, buffer contains ASCII NULs */
+    isglobal = 0;            /* if set, doing a global command */
+    modified = 0;            /* if set, buffer modified since last write */
+    mutex = 0;            /* if set, signals set "sigflags" */
+    red = 0;            /* if set, restrict shell/directory access */
+    scripted = 0;        /* if set, suppress diagnostics */
+    sigflags = 0;        /* if set, signals received while mutex set */
+    sigactive = 0;        /* if set, signal handlers are enabled */
+    posixly_correct = 0;    /* if set, POSIX behavior as per */
+    /* http://www.opengroup.org/onlinepubs/009695399/utilities/ed.html */
+    
+    old_filename[0] = 0x0;    /* default filename */
+    current_addr = 0;        /* current address in editor buffer */
+    addr_last = 0;            /* last address in editor buffer */
+    ed_lineno = 0;            /* script line number */
+    prompt = 0;        /* command-line prompt */
+    shcmd = 0;            /* shell command buffer */
+    shcmdsz = 0;            /* shell command buffer size */
+    shcmdi = 0;            /* shell command buffer index */
+    ibuf = 0;            /* ed command-line buffer */
+    ibufsz = 0;            /* ed command-line buffer size */
+    ibufp = 0;            /* pointer to ed command-line buffer */
+
+    
 #if __GNUC__
 	/* Avoid longjmp clobbering */
 	(void) &argc;
@@ -141,8 +173,9 @@
 			break;
 
 		default:
-			fprintf(stderr, usage, red ? "red" : "ed");
-			exit(1);
+			fprintf(stderr, ed_usage, red ? "red" : "ed");
+            pthread_exit(NULL);
+			// exit(1);
 		}
 	argv += optind;
 	argc -= optind;
@@ -210,7 +243,7 @@
 				if (!isatty(0)) {
 					fprintf(stderr, garrulous ?
 					    "script, line %d: %s\n" :
-					    "", lineno, errmsg);
+					    "", ed_lineno, errmsg);
 					quit(2);
 				}
 				clearerr(stdin);
@@ -243,7 +276,7 @@
 			if (!isatty(0)) {
 				fprintf(stderr, garrulous ?
 				    "script, line %d: %s\n" :
-				    "", lineno, errmsg);
+				    "", ed_lineno, errmsg);
 				quit(2);
 			}
 			break;
@@ -251,7 +284,7 @@
 			if (!isatty(0))
 				fprintf(stderr, garrulous ?
 				    "script, line %d: %s\n" : "",
-				    lineno, errmsg);
+				    ed_lineno, errmsg);
 			else
 				fprintf(stderr, garrulous ? "%s\n" : "",
 				    errmsg);
@@ -261,7 +294,7 @@
 			if (!isatty(0)) {
 				fprintf(stderr, garrulous ?
 				    "script, line %d: %s\n" : "",
-				    lineno, errmsg);
+				    ed_lineno, errmsg);
 				quit(2);
 			}
 			break;
@@ -888,7 +921,7 @@
 		GET_COMMAND_SUFFIX();
 		if (sflags) printf("%s\n", shcmd + 1);
 		fflush(stdout);
-		system(shcmd + 1);
+		ios_system(shcmd + 1);
 		if (!scripted) printf("!\n");
 		break;
 	case '\n':
diff -Naur text_cmds-99/grep/file.c text_cmds/grep/file.c
--- text_cmds-99/grep/file.c	2015-08-18 22:29:43.000000000 +0200
+++ text_cmds/grep/file.c	2018-01-10 11:31:02.000000000 +0100
@@ -38,7 +38,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #ifndef WITHOUT_LZMA
diff -Naur text_cmds-99/grep/grep.c text_cmds/grep/grep.c
--- text_cmds-99/grep/grep.c	2015-08-18 22:29:43.000000000 +0200
+++ text_cmds/grep/grep.c	2018-01-10 11:31:02.000000000 +0100
@@ -36,7 +36,7 @@
 #include <sys/types.h>
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>
@@ -53,6 +53,7 @@
 #include "fastmatch.h"
 #endif
 #include "grep.h"
+#include "ios_error.h"
 
 #ifndef WITHOUT_NLS
 #include <nl_types.h>
@@ -67,7 +68,7 @@
 	"",
 /* 1*/	"(standard input)",
 /* 2*/	"cannot read bzip2 compressed file",
-/* 3*/	"unknown %s option",
+/* 3*/	"grep: unknown %s option\n",
 #ifdef __APPLE__
 /* 4*/	"usage: %s [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]]\n",
 #else
@@ -158,13 +159,16 @@
 int	 tail;		/* lines left to print */
 bool	 file_err;	/* file reading error */
 
+static char* progname;
+
 /*
  * Prints usage information and returns 2.
  */
 static void
 usage(void)
 {
-	fprintf(stderr, getstr(4), getprogname());
+	// fprintf(stderr, getstr(4), getprogname());
+    fprintf(stderr, getstr(4), progname);
 	fprintf(stderr, "%s", getstr(5));
 	fprintf(stderr, "%s", getstr(6));
 	fprintf(stderr, "%s", getstr(7));
@@ -328,16 +332,22 @@
 	char *line;
 	size_t len;
 
-	if ((f = fopen(fn, "r")) == NULL)
-		err(2, "%s", fn);
+    if ((f = fopen(fn, "r")) == NULL) {
+		// err(2, "%s", fn);
+        fprintf(stderr, "grep: %s: %s\n", fn, strerror(errno));
+        pthread_exit(NULL);
+    }
 	if ((fstat(fileno(f), &st) == -1) || (S_ISDIR(st.st_mode))) {
 		fclose(f);
 		return;
 	}
         while ((line = fgetln(f, &len)) != NULL)
 		add_pattern(line, line[0] == '\n' ? 0 : len);
-	if (ferror(f))
-		err(2, "%s", fn);
+    if (ferror(f)) {
+		// err(2, "%s", fn);
+        fprintf(stderr, "grep: %s: %s\n", fn, strerror(errno));
+        pthread_exit(NULL);
+    }
 	fclose(f);
 }
 
@@ -351,7 +361,7 @@
 }
 
 int
-main(int argc, char *argv[])
+grep_main(int argc, char *argv[])
 {
 	char **aargv, **eargv, *eopts;
 	char *ep;
@@ -360,8 +370,37 @@
 	unsigned int aargc, eargc, i;
 	int c, lastc, needpattern, newarg, prevoptind;
 
-	setlocale(LC_ALL, "");
-
+    setlocale(LC_ALL, "");
+    // Initialize all variables and flags:
+    optind = 1; opterr = 1; optreset = 1;
+    patterns = pattern_sz = 0;
+    fpatterns = fpattern_sz = 0;
+    dpatterns = dpattern_sz = 0;
+    
+    pattern = NULL;
+    dpattern = NULL;
+    fpattern = NULL;
+    
+    cflags = REG_NOSUB;
+    eflags = REG_STARTEND;
+    
+    matchall = false;
+    
+    Aflag = Bflag = 0;
+    Hflag = Lflag = bflag = cflag = hflag = iflag = lflag = mflag = false;
+    mcount = 0;
+    nflag = oflag = qflag = sflag = vflag = wflag = xflag = lbflag = nullflag = false;
+    label = NULL;
+    grepbehave = GREP_BASIC;
+    binbehave = BINFILE_BIN;
+    filebehave = FILE_STDIO;
+    devbehave = DEV_READ;
+    dirbehave = DIR_READ;
+    linkbehave = LINK_READ;
+    
+    dexclude = dinclude = false;
+    fexclude = finclude = false;
+    
 #ifndef WITHOUT_NLS
 	catalog = catopen("grep", NL_CAT_LOCALE);
 #endif
@@ -369,7 +408,9 @@
 	/* Check what is the program name of the binary.  In this
 	   way we can have all the funcionalities in one binary
 	   without the need of scripting and using ugly hacks. */
-	pn = getprogname();
+	// pn = getprogname();
+    pn = argv[0];
+    progname = argv[0]; 
 	if (pn[0] == 'b' && pn[1] == 'z') {
 		filebehave = FILE_BZIP;
 		pn += 2;
@@ -441,7 +482,9 @@
 				Aflag = 0;
 			else if (Aflag > LLONG_MAX / 10) {
 				errno = ERANGE;
-				err(2, NULL);
+                fprintf(stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+				// err(2, NULL);
 			}
 			Aflag = Bflag = (Aflag * 10) + (c - '0');
 			break;
@@ -457,11 +500,16 @@
 			errno = 0;
 			l = strtoull(optarg, &ep, 10);
 			if (((errno == ERANGE) && (l == ULLONG_MAX)) ||
-			    ((errno == EINVAL) && (l == 0)))
-				err(2, NULL);
+                ((errno == EINVAL) && (l == 0))) {
+                fprintf(stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
+            }
 			else if (ep[0] != '\0') {
 				errno = EINVAL;
-				err(2, NULL);
+                fprintf(stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
 			}
 			if (c == 'A')
 				Aflag = l;
@@ -484,8 +532,11 @@
 				devbehave = DEV_SKIP;
 			else if (strcasecmp(optarg, "read") == 0)
 				devbehave = DEV_READ;
-			else
-				errx(2, getstr(3), "--devices");
+            else {
+				// errx(2, getstr(3), "--devices");
+                fprintf(stderr, getstr(3), "--devices");
+                pthread_exit(NULL);
+            }
 			break;
 		case 'd':
 			if (strcasecmp("recurse", optarg) == 0) {
@@ -495,8 +546,11 @@
 				dirbehave = DIR_SKIP;
 			else if (strcasecmp("read", optarg) == 0)
 				dirbehave = DIR_READ;
-			else
-				errx(2, getstr(3), "--directories");
+            else {
+				// errx(2, getstr(3), "--directories");
+                fprintf(stderr, getstr(3), "--directories");
+                pthread_exit(NULL);
+            }
 			break;
 		case 'E':
 			grepbehave = GREP_EXTENDED;
@@ -533,7 +587,9 @@
 		case 'J':
 #ifdef WITHOUT_BZIP2
 			errno = EOPNOTSUPP;
-			err(2, "bzip2 support was disabled at compile-time");
+			// err(2, "bzip2 support was disabled at compile-time");
+                fprintf(stderr, "grep: bzip2 support was disabled at compile-time: %s\n", strerror(errno));
+            pthread_exit(NULL);
 #endif
 			filebehave = FILE_BZIP;
 			break;
@@ -550,17 +606,24 @@
 			errno = 0;
 			mcount = strtoll(optarg, &ep, 10);
 			if (((errno == ERANGE) && (mcount == LLONG_MAX)) ||
-			    ((errno == EINVAL) && (mcount == 0)))
-				err(2, NULL);
+                ((errno == EINVAL) && (mcount == 0))) {
+                fprintf(stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
+            }
 			else if (ep[0] != '\0') {
 				errno = EINVAL;
-				err(2, NULL);
+                fprintf(stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
 			}
 			break;
 		case 'M':
 #ifdef WITHOUT_LZMA
 			errno = EOPNOTSUPP;
-			err(2, "lzma support was disabled at compile-time");
+			// err(2, "lzma support was disabled at compile-time");
+                fprintf(stderr, "grep: lzma support was disabled at compile-time: %s\n", strerror(errno));
+            pthread_exit(NULL);
 #endif
 			filebehave = FILE_LZMA;
 			break;
@@ -602,7 +665,7 @@
 #endif
 			break;
 		case 'V':
-			printf(getstr(9), getprogname(), VERSION);
+			printf(getstr(9), progname, VERSION);
 			exit(0);
 		case 'v':
 			vflag = true;
@@ -618,7 +681,9 @@
 		case 'X':
 #ifdef WITHOUT_LZMA
 			errno = EOPNOTSUPP;
-			err(2, "xz support was disabled at compile-time");
+			// err(2, "xz support was disabled at compile-time");
+                fprintf(stderr, "grep: xz support was disabled at compile-time: %s\n", strerror(errno));
+            pthread_exit(NULL);
 #endif
 			filebehave = FILE_XZ;
 			break;
@@ -632,8 +697,11 @@
 				binbehave = BINFILE_SKIP;
 			else if (strcasecmp("text", optarg) == 0)
 				binbehave = BINFILE_TEXT;
-			else
-				errx(2, getstr(3), "--binary-files");
+            else {
+				// errx(2, getstr(3), "--binary-files");
+                fprintf(stderr, getstr(3), "--binary-files");
+                pthread_exit(NULL);
+            }
 			break;
 		case COLOR_OPT:
 			color = NULL;
@@ -652,8 +720,11 @@
 				color = init_color("01;31");
 			} else if (strcasecmp("never", optarg) != 0 &&
 			    strcasecmp("none", optarg) != 0 &&
-			    strcasecmp("no", optarg) != 0)
-				errx(2, getstr(3), "--color");
+                strcasecmp("no", optarg) != 0) {
+				// errx(2, getstr(3), "--color");
+                fprintf(stderr, getstr(3), "--color");
+                pthread_exit(NULL);
+            }
 			cflags &= ~REG_NOSUB;
 			break;
 		case LABEL_OPT:
@@ -748,7 +819,9 @@
 			if (c != 0) {
 				regerror(c, &r_pattern[i], re_error,
 				    RE_ERROR_BUF);
-				errx(2, "%s", re_error);
+				// errx(2, "%s", re_error);
+                fprintf(stderr, "grep: %s\n", re_error);
+                pthread_exit(NULL);
 			}
 #ifndef WITHOUT_FASTMATCH
 		}
diff -Naur text_cmds-99/grep/util.c text_cmds/grep/util.c
--- text_cmds-99/grep/util.c	2015-09-10 22:25:31.000000000 +0200
+++ text_cmds/grep/util.c	2018-01-10 11:31:02.000000000 +0100
@@ -39,7 +39,7 @@
 #endif
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fnmatch.h>
 #include <fts.h>
@@ -59,6 +59,7 @@
 #include "fastmatch.h"
 #endif
 #include "grep.h"
+#include "ios_error.h"
 
 static int	 linesqueued;
 static int	 procline(struct str *l, int);
@@ -135,8 +136,11 @@
 
 	fts_flags |= FTS_NOSTAT | FTS_NOCHDIR;
 
-	if (!(fts = fts_open(argv, fts_flags, NULL)))
-		err(2, "fts_open");
+    if (!(fts = fts_open(argv, fts_flags, NULL))) {
+		// err(2, "fts_open");
+        fprintf(stderr, "grep: fts_open: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	while ((p = fts_read(fts)) != NULL) {
 		switch (p->fts_info) {
 		case FTS_DNR:
@@ -144,7 +148,8 @@
 		case FTS_ERR:
 			file_err = true;
 			if(!sflag)
-				warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
+                fprintf(stderr, "grep: %s: %s\n", p->fts_path, strerror(p->fts_errno));
+                // warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
 			break;
 		case FTS_D:
 			/* FALLTHROUGH */
@@ -156,7 +161,8 @@
 			break;
 		case FTS_DC:
 			/* Print a warning for recursive directory loop */
-			warnx("warning: %s: recursive directory loop",
+			// warnx("warning: %s: recursive directory loop",
+                fprintf(stderr, "grep; warning: %s: recursive directory loop\n",
 				p->fts_path);
 			break;
 		default:
@@ -195,7 +201,8 @@
 #ifdef __APPLE__
 		/* 4053512, 10290183 */
 		if (dirbehave == DIR_RECURSE && isatty(STDIN_FILENO)) {
-			warnx("warning: recursive search of stdin");
+            fprintf(stderr, "grep: warning: recursive search of stdin\n");
+            // warnx("warning: recursive search of stdin");
 		}
 #endif
 		fn = label != NULL ? label : getstr(1);
@@ -215,7 +222,8 @@
 	if (f == NULL) {
 		file_err = true;
 		if (!sflag)
-			warn("%s", fn);
+            fprintf(stderr, "grep: %s: %s\n", fn, strerror(errno));
+            // warn("%s", fn);
 		return (0);
 	}
 
@@ -494,8 +502,11 @@
 {
 	void *ptr;
 
-	if ((ptr = malloc(size)) == NULL)
-		err(2, "malloc");
+    if ((ptr = malloc(size)) == NULL) {
+		// err(2, "malloc");
+        fprintf(stderr, "grep: malloc: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	return (ptr);
 }
 
@@ -507,8 +518,11 @@
 {
 	void *ptr;
 
-	if ((ptr = calloc(nmemb, size)) == NULL)
-		err(2, "calloc");
+    if ((ptr = calloc(nmemb, size)) == NULL) {
+        // err(2, "calloc");
+        fprintf(stderr, "grep: calloc: %s\n", strerror(errno));
+    pthread_exit(NULL);
+}
 	return (ptr);
 }
 
@@ -519,8 +533,11 @@
 grep_realloc(void *ptr, size_t size)
 {
 
-	if ((ptr = realloc(ptr, size)) == NULL)
-		err(2, "realloc");
+    if ((ptr = realloc(ptr, size)) == NULL) {
+        // err(2, "realloc");
+        fprintf(stderr, "grep: realloc: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	return (ptr);
 }
 
@@ -532,8 +549,11 @@
 {
 	char *ret;
 
-	if ((ret = strdup(str)) == NULL)
-		err(2, "strdup");
+    if ((ret = strdup(str)) == NULL) {
+        // err(2, "strdup");
+        fprintf(stderr, "grep: strdup: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	return (ret);
 }
 
diff -Naur text_cmds-99/sed/compile.c text_cmds/sed/compile.c
--- text_cmds-99/sed/compile.c	2006-12-05 23:29:30.000000000 +0100
+++ text_cmds/sed/compile.c	2018-01-10 11:31:02.000000000 +0100
@@ -54,12 +54,13 @@
 
 #include "defs.h"
 #include "extern.h"
+#include "ios_error.h"
 
-#ifdef __APPLE__
-#include <get_compat.h>
-#else
+// #ifdef __APPLE__
+// #include <get_compat.h>
+// #else
 #define COMPAT_MODE(a,b) (1)
-#endif /* __APPLE__ */
+// #endif /* __APPLE__ */
 
 #define LHSZ	128
 #define	LHMASK	(LHSZ - 1)
@@ -145,9 +146,9 @@
 		appends = NULL;
 	else if ((appends = malloc(sizeof(struct s_appends) * appendnum)) ==
 	    NULL)
-		err(1, "malloc");
+    { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	if ((match = malloc((maxnsub + 1) * sizeof(regmatch_t))) == NULL)
-		err(1, "malloc");
+    { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 }
 
 #define EATSPACE() do {							\
@@ -169,8 +170,11 @@
 	for (;;) {
 		if ((p = cu_fgets(lbuf, sizeof(lbuf), NULL)) == NULL) {
 			if (stack != 0)
-				errx(1, "%lu: %s: unexpected EOF (pending }'s)",
+            { fprintf(stderr, "sed: %lu: %s: unexpected EOF (pending }'s)\n",
+				// errx(1, "%lu: %s: unexpected EOF (pending }'s)",
 							linenum, fname);
+                pthread_exit(NULL);
+            }
 			return (link);
 		}
 
@@ -184,7 +188,7 @@
 			}
 		}
 		if ((*link = cmd = malloc(sizeof(struct s_command))) == NULL)
-			err(1, "malloc");
+        { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 		link = &cmd->next;
 		cmd->nonsel = cmd->inrange = 0;
 		/* First parse the addresses */
@@ -195,7 +199,7 @@
 		if (addrchar(*p)) {
 			naddr++;
 			if ((cmd->a1 = malloc(sizeof(struct s_addr))) == NULL)
-				err(1, "malloc");
+            { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 			p = compile_addr(p, cmd->a1);
 			EATSPACE();				/* EXTENSION */
 			if (*p == ',') {
@@ -204,7 +208,7 @@
 				naddr++;
 				if ((cmd->a2 = malloc(sizeof(struct s_addr)))
 				    == NULL)
-					err(1, "malloc");
+                { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 				p = compile_addr(p, cmd->a2);
 				EATSPACE();
 			} else
@@ -214,17 +218,24 @@
 
 nonsel:		/* Now parse the command */
 		if (!*p)
-			errx(1, "%lu: %s: command expected", linenum, fname);
+        { fprintf(stderr, "sed: %lu: %s: command expected\n", linenum, fname); pthread_exit(NULL); }
+            // errx(1, "%lu: %s: command expected", linenum, fname);
 		cmd->code = *p;
 		for (fp = cmd_fmts; fp->code; fp++)
 			if (fp->code == *p)
 				break;
 		if (!fp->code)
-			errx(1, "%lu: %s: invalid command code %c", linenum, fname, *p);
+        { fprintf(stderr, "sed: %lu: %s: invalid command code %c\n", linenum, fname, *p); pthread_exit(NULL); }
+			// errx(1, "%lu: %s: invalid command code %c", linenum, fname, *p);
 		if (naddr > fp->naddr)
-			errx(1,
-				"%lu: %s: command %c expects up to %d address(es), found %d",
-				linenum, fname, *p, fp->naddr, naddr);
+        { fprintf(stderr,
+                  "sed: %lu: %s: command %c expects up to %d address(es), found %d\n",
+                 linenum, fname, *p, fp->naddr, naddr);
+            pthread_exit(NULL);
+        }
+			// errx(1,
+			//	"%lu: %s: command %c expects up to %d address(es), found %d",
+			//	linenum, fname, *p, fp->naddr, naddr);
 		switch (fp->args) {
 		case NONSEL:			/* ! */
 			p++;
@@ -247,7 +258,8 @@
 			 */
 			cmd->nonsel = 1;
 			if (stack == 0)
-				errx(1, "%lu: %s: unexpected }", linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: unexpected }\n", linenum, fname); pthread_exit(NULL); }
+                // errx(1, "%lu: %s: unexpected }", linenum, fname);
 			cmd2 = stack;
 			stack = cmd2->next;
 			cmd2->next = cmd;
@@ -261,21 +273,31 @@
 				goto semicolon;
 			}
 			if (*p)
-				errx(1, "%lu: %s: extra characters at the end of %c command",
-						linenum, fname, cmd->code);
+            { fprintf(stderr, "sed: %lu: %s: extra characters at the end of %c command\n", linenum, fname, cmd->code); pthread_exit(NULL); }
+				// errx(1, "%lu: %s: extra characters at the end of %c command",
+						// linenum, fname, cmd->code);
 			break;
 		case TEXT:			/* a c i */
 			p++;
 			EATSPACE();
 			if (*p != '\\')
-				errx(1,
-"%lu: %s: command %c expects \\ followed by text", linenum, fname, cmd->code);
+            { fprintf(stderr,
+                      "sed: %lu: %s: command %c expects \\ followed by text\n", linenum, fname, cmd->code);
+                pthread_exit(NULL);
+            }
+				// errx(1,
+// "%lu: %s: command %c expects \\ followed by text", linenum, fname, cmd->code);
 			p++;
 			EATSPACE();
 			if (*p)
-				errx(1,
-				"%lu: %s: extra characters after \\ at the end of %c command",
-				linenum, fname, cmd->code);
+            { fprintf(stderr,
+                      "sed: %lu: %s: extra characters after \\ at the end of %c command\n",
+                     linenum, fname, cmd->code);
+                pthread_exit(NULL);
+            }
+				// errx(1,
+				// "%lu: %s: extra characters after \\ at the end of %c command",
+				//linenum, fname, cmd->code);
 			cmd->t = compile_text();
 			break;
 		case COMMENT:			/* \0 # */
@@ -284,20 +306,26 @@
 			p++;
 			EATSPACE();
 			if (*p == '\0')
-				errx(1, "%lu: %s: filename expected", linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: filename expected\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+             //   errx(1, "%lu: %s: filename expected", linenum, fname);
 			cmd->t = duptoeol(p, "w command");
 			if (aflag)
 				cmd->u.fd = -1;
 			else if ((cmd->u.fd = open(p,
 			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
 			    DEFFILEMODE)) == -1)
-				err(1, "%s", p);
+            { fprintf(stderr, "sed: %s: %s\n", p, strerror(errno)); pthread_exit(NULL); }  // err(1, "%s", p);
 			break;
 		case RFILE:			/* r */
 			p++;
 			EATSPACE();
 			if (*p == '\0')
-				errx(1, "%lu: %s: filename expected", linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: filename expected\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				// errx(1, "%lu: %s: filename expected", linenum, fname);
 			else
 				cmd->t = duptoeol(p, "read command");
 			break;
@@ -314,21 +342,30 @@
 			EATSPACE();
 			cmd->t = duptoeol(p, "label");
 			if (strlen(p) == 0)
-				errx(1, "%lu: %s: empty label", linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: empty label\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+			//	errx(1, "%lu: %s: empty label", linenum, fname);
 			enterlabel(cmd);
 			break;
 		case SUBST:			/* s */
 			p++;
 			if (*p == '\0' || *p == '\\')
-				errx(1,
-"%lu: %s: substitute pattern can not be delimited by newline or backslash",
-					linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: substitute pattern can not be delimited by newline or backslash\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				// errx(1,
+//"%lu: %s: substitute pattern can not be delimited by newline or backslash",
+	//				linenum, fname);
 			if ((cmd->u.s = malloc(sizeof(struct s_subst))) == NULL)
-				err(1, "malloc");
+            { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 			p = compile_re(p, &cmd->u.s->re);
 			if (p == NULL)
-				errx(1,
-				"%lu: %s: unterminated substitute pattern", linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: unterminated substitute pattern\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				//errx(1,
+				// "%lu: %s: unterminated substitute pattern", linenum, fname);
 			--p;
 			p = compile_subst(p, cmd->u.s);
 			p = compile_flags(p, cmd->u.s);
@@ -349,8 +386,12 @@
 				goto semicolon;
 			}
 			if (*p)
-				errx(1,
-"%lu: %s: extra text at the end of a transform command", linenum, fname);
+            { fprintf(stderr,
+                      "sed: %lu: %s: extra text at the end of a transform command\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				//errx(1,
+//"%lu: %s: extra text at the end of a transform command", linenum, fname);
 			break;
 		}
 	}
@@ -374,15 +415,24 @@
 	if (c == '\0')
 		return (NULL);
 	else if (c == '\\')
-		errx(1, "%lu: %s: \\ can not be used as a string delimiter",
+    { fprintf(stderr, "sed: %lu: %s: \\ can not be used as a string delimiter\n",
+             //errx(1, "%lu: %s: \\ can not be used as a string delimiter",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	else if (c == '\n')
-		errx(1, "%lu: %s: newline can not be used as a string delimiter",
+    { fprintf(stderr, "sed: %lu: %s: newline can not be used as a string delimiter\n",
+              // errx(1, "%lu: %s: newline can not be used as a string delimiter",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	while (*p) {
 		if (*p == '[' && c != *p) {
 			if ((d = compile_ccl(&p, d)) == NULL)
-				errx(1, "%lu: %s: unbalanced brackets ([])", linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: unbalanced brackets ([])", linenum, fname);
+				//errx(1, "%lu: %s: unbalanced brackets ([])", linenum, fname);
+                pthread_exit(NULL);
+            }
 			continue;
 		} else if (*p == '\\' && p[1] == '[') {
 			*d++ = *p++;
@@ -451,10 +501,13 @@
 		return (p);
 	}
 	if ((*repp = malloc(sizeof(regex_t))) == NULL)
-		err(1, "malloc");
+    { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	if (p && (eval = regcomp(*repp, re, rflags)) != 0)
-		errx(1, "%lu: %s: RE error: %s",
+    { fprintf(stderr, "sed: %lu: %s: RE error: %s\n",
+		// errx(1, "%lu: %s: RE error: %s",
 				linenum, fname, strregerror(eval, *repp));
+        pthread_exit(NULL);
+    }
 	if (maxnsub < (*repp)->re_nsub)
 		maxnsub = (*repp)->re_nsub;
 	return (p);
@@ -482,7 +535,7 @@
 	s->linenum = linenum;
 	asize = 2 * _POSIX2_LINE_MAX + 1;
 	if ((text = malloc(asize)) == NULL)
-		err(1, "malloc");
+    { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	size = 0;
 	do {
 		op = sp = text + size;
@@ -514,8 +567,11 @@
 					ref = *p - '0';
 					if (s->re != NULL &&
 					    ref > s->re->re_nsub)
-						errx(1, "%lu: %s: \\%c not defined in the RE",
+                    { fprintf(stderr, "sed: %lu: %s: \\%c not defined in the RE\n",
+						// errx(1, "%lu: %s: \\%c not defined in the RE",
 								linenum, fname, *p);
+                        pthread_exit(NULL);
+                    }
 					if (s->maxbref < ref)
 						s->maxbref = ref;
 				} else if (*p == '&' || *p == '\\')
@@ -528,11 +584,13 @@
 				*sp++ = '\0';
 				size += sp - op;
 				if ((s->new = realloc(text, size)) == NULL)
-					err(1, "realloc");
+                { fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 				return (p);
 			} else if (*p == '\n') {
-				errx(1,
-"%lu: %s: unescaped newline inside substitute pattern", linenum, fname);
+				fprintf(stderr,
+                    // errx(1,
+                        "sed: %lu: %s: unescaped newline inside substitute pattern\n", linenum, fname);
+                pthread_exit(NULL);
 				/* NOTREACHED */
 			}
 			*sp++ = *p;
@@ -541,11 +599,13 @@
 		if (asize - size < _POSIX2_LINE_MAX + 1) {
 			asize *= 2;
 			if ((text = realloc(text, asize)) == NULL)
-				err(1, "realloc");
+            { fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 		}
 	} while (cu_fgets(p = lbuf, sizeof(lbuf), &more));
-	errx(1, "%lu: %s: unterminated substitute in regular expression",
+    fprintf(stderr, "sed: %lu: %s: unterminated substitute in regular expression\n",
+         // errx(1, "%lu: %s: unterminated substitute in regular expression",
 			linenum, fname);
+    pthread_exit(NULL);
 	/* NOTREACHED */
 }
 
@@ -568,8 +628,11 @@
 		switch (*p) {
 		case 'g':
 			if (gn)
-				errx(1,
-"%lu: %s: more than one number or 'g' in substitute flags", linenum, fname);
+            { fprintf(stderr,
+                     //errx(1,
+                      "sed: %lu: %s: more than one number or 'g' in substitute flags\n", linenum, fname);
+                pthread_exit(NULL);
+            }
 			gn = 1;
 			s->n = 0;
 			break;
@@ -584,14 +647,20 @@
 		case '4': case '5': case '6':
 		case '7': case '8': case '9':
 			if (gn)
-				errx(1,
-"%lu: %s: more than one number or 'g' in substitute flags", linenum, fname);
+            { fprintf(stderr,
+				// errx(1,
+                      "sed: %lu: %s: more than one number or 'g' in substitute flags\n", linenum, fname);
+                pthread_exit(NULL);
+            }
 			gn = 1;
 			errno = 0;
 			nval = strtol(p, &p, 10);
 			if (errno == ERANGE || nval > INT_MAX)
-				errx(1,
-"%lu: %s: overflow in the 'N' substitute flag", linenum, fname);
+            { fprintf(stderr,
+				//errx(1,
+                      "sed: %lu: %s: overflow in the 'N' substitute flag\n", linenum, fname);
+                pthread_exit(NULL);
+            }
 			s->n = nval;
 			p--;
 			break;
@@ -599,7 +668,8 @@
 			p++;
 #ifdef HISTORIC_PRACTICE
 			if (*p != ' ') {
-				warnx("%lu: %s: space missing before w wfile", linenum, fname);
+                fprintf(stder, "sed: %lu: %s: space missing before w wfile\n", linenum, fname);
+				// warnx("%lu: %s: space missing before w wfile", linenum, fname);
 				return (p);
 			}
 #endif
@@ -612,16 +682,21 @@
 			}
 			*q = '\0';
 			if (q == wfile)
-				errx(1, "%lu: %s: no wfile specified", linenum, fname);
+            { fprintf(stderr, "sed: %lu: %s: no wfile specified\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+                // errx(1, "%lu: %s: no wfile specified", linenum, fname);
 			s->wfile = strdup(wfile);
 			if (!aflag && (s->wfd = open(wfile,
 			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
 			    DEFFILEMODE)) == -1)
-				err(1, "%s", wfile);
+            { fprintf(stderr, "sed: %s: %s\n", wfile, strerror(errno)); pthread_exit(NULL); } // err(1, "%s", wfile);
 			return (p);
 		default:
-			errx(1, "%lu: %s: bad flag in substitute command: '%c'",
+                fprintf(stderr, "sed: %lu: %s: bad flag in substitute command: '%c'\n",
+			// errx(1, "%lu: %s: bad flag in substitute command: '%c'",
 					linenum, fname, *p);
+                pthread_exit(NULL);
 			break;
 		}
 		p++;
@@ -643,34 +718,46 @@
 	mbstate_t mbs1, mbs2;
 
 	if ((*py = y = malloc(sizeof(*y))) == NULL)
-		err(1, NULL);
+    { fprintf(stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	y->multis = NULL;
 	y->nmultis = 0;
 
 	if (*p == '\0' || *p == '\\')
-		errx(1,
-	"%lu: %s: transform pattern can not be delimited by newline or backslash",
+    { fprintf(stderr,
+             // errx(1,
+              "sed: %lu: %s: transform pattern can not be delimited by newline or backslash\n",
 			linenum, fname);
+        pthread_exit(NULL);
+    }
 	p = compile_delimited(p, old, 1);
 	if (p == NULL)
-		errx(1, "%lu: %s: unterminated transform source string",
+    { fprintf(stderr, "sed: %lu: %s: unterminated transform source string\n",
+		// errx(1, "%lu: %s: unterminated transform source string",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	p = compile_delimited(p - 1, new, 1);
 	if (p == NULL)
-		errx(1, "%lu: %s: unterminated transform target string",
+    { fprintf(stderr, "sed: %lu: %s: unterminated transform target string\n",
+		// errx(1, "%lu: %s: unterminated transform target string",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	EATSPACE();
 	op = old;
 	oldlen = mbsrtowcs(NULL, &op, 0, NULL);
 	if (oldlen == (size_t)-1)
-		err(1, NULL);
+    { fprintf(stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	np = new;
 	newlen = mbsrtowcs(NULL, &np, 0, NULL);
 	if (newlen == (size_t)-1)
-		err(1, NULL);
+    { fprintf(stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	if (newlen != oldlen)
-		errx(1, "%lu: %s: transform strings are not the same length",
+    { fprintf(stderr, "sed: %lu: %s: transform strings are not the same length\n",
+		// errx(1, "%lu: %s: transform strings are not the same length",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	if (MB_CUR_MAX == 1) {
 		/*
 		 * The single-byte encoding case is easy: generate a
@@ -706,7 +793,7 @@
 				y->multis = realloc(y->multis,
 				    (y->nmultis + 1) * sizeof(*y->multis));
 				if (y->multis == NULL)
-					err(1, NULL);
+                { fprintf(stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 				i = y->nmultis++;
 				y->multis[i].fromlen = oclen;
 				memcpy(y->multis[i].from, op, oclen);
@@ -732,7 +819,7 @@
 
 	asize = 2 * _POSIX2_LINE_MAX + 1;
 	if ((text = malloc(asize)) == NULL)
-		err(1, "malloc");
+    { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	size = 0;
 	while (cu_fgets(lbuf, sizeof(lbuf), NULL)) {
 		op = s = text + size;
@@ -751,12 +838,12 @@
 		if (asize - size < _POSIX2_LINE_MAX + 1) {
 			asize *= 2;
 			if ((text = realloc(text, asize)) == NULL)
-				err(1, "realloc");
+            { fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 		}
 	}
 	text[size] = '\0';
 	if ((p = realloc(text, size + 1)) == NULL)
-		err(1, "realloc");
+    { fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	return (p);
 }
 
@@ -776,7 +863,10 @@
 	case '/':				/* Context address */
 		p = compile_re(p, &a->u.r);
 		if (p == NULL)
-			errx(1, "%lu: %s: unterminated regular expression", linenum, fname);
+        { fprintf(stderr, "sed: %lu: %s: unterminated regular expression\n", linenum, fname);
+            pthread_exit(NULL);
+         //   errx(1, "%lu: %s: unterminated regular expression", linenum, fname);
+        }
 		a->type = AT_RE;
 		return (p);
 
@@ -790,7 +880,9 @@
 		a->u.l = strtol(p, &end, 10);
 		return (end);
 	default:
-		errx(1, "%lu: %s: expected context address", linenum, fname);
+            fprintf(stderr, "sed: %lu: %s: expected context address\n", linenum, fname);
+            pthread_exit(NULL);
+		// errx(1, "%lu: %s: expected context address", linenum, fname);
 		return (NULL);
 	}
 }
@@ -811,10 +903,11 @@
 		ws = isspace((unsigned char)*s);
 	*s = '\0';
 	if (ws)
-		warnx("%lu: %s: whitespace after %s", linenum, fname, ctype);
+        fprintf(stderr, "sed: %lu: %s: whitespace after %s\n", linenum, fname, ctype);
+		// warnx("%lu: %s: whitespace after %s", linenum, fname, ctype);
 	len = s - start + 1;
 	if ((p = malloc(len)) == NULL)
-		err(1, "malloc");
+    { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	return (memmove(p, start, len));
 }
 
@@ -843,7 +936,10 @@
 				break;
 			}
 			if ((cp->u.c = findlabel(cp->t)) == NULL)
-				errx(1, "%lu: %s: undefined label '%s'", linenum, fname, cp->t);
+            { fprintf(stderr, "sed: %lu: %s: undefined label '%s'\n", linenum, fname, cp->t);
+                pthread_exit(NULL);
+                // errx(1, "%lu: %s: undefined label '%s'", linenum, fname, cp->t);
+            }
 			free(cp->t);
 			break;
 		case '{':
@@ -868,9 +964,12 @@
 	lhp = &labels[h & LHMASK];
 	for (lh = *lhp; lh != NULL; lh = lh->lh_next)
 		if (lh->lh_hash == h && strcmp(cp->t, lh->lh_cmd->t) == 0)
-			errx(1, "%lu: %s: duplicate label '%s'", linenum, fname, cp->t);
+        { fprintf(stderr, "sed: %lu: %s: duplicate label '%s'\n", linenum, fname, cp->t);
+            pthread_exit(NULL);
+    // errx(1, "%lu: %s: duplicate label '%s'", linenum, fname, cp->t);
+        }
 	if ((lh = malloc(sizeof *lh)) == NULL)
-		err(1, "malloc");
+    { fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	lh->lh_next = *lhp;
 	lh->lh_hash = h;
 	lh->lh_cmd = cp;
@@ -925,8 +1024,8 @@
 				continue;
 			}
 			if (!lh->lh_ref)
-				warnx("%lu: %s: unused label '%s'",
-				    linenum, fname, lh->lh_cmd->t);
+                fprintf(stderr, "sed: %lu: %s: unused label '%s'\n", linenum, fname, lh->lh_cmd->t);
+            // warnx("%lu: %s: unused label '%s'", linenum, fname, lh->lh_cmd->t);
 			free(lh);
 		}
 	}
diff -Naur text_cmds-99/sed/extern.h text_cmds/sed/extern.h
--- text_cmds-99/sed/extern.h	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/extern.h	2018-01-10 11:31:02.000000000 +0100
@@ -40,7 +40,7 @@
 extern size_t maxnsub;
 extern u_long linenum;
 extern int appendnum;
-extern int aflag, eflag, nflag;
+extern int aflag, eflag, sed_nflag;
 extern const char *fname, *outfname;
 extern FILE *infile, *outfile;
 extern int rflags;	/* regex flags to use */
diff -Naur text_cmds-99/sed/main.c text_cmds/sed/main.c
--- text_cmds-99/sed/main.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/main.c	2018-01-10 11:31:02.000000000 +0100
@@ -64,6 +64,9 @@
 
 #include "defs.h"
 #include "extern.h"
+// iOS changes:
+#include "ios_error.h"
+#include <pthread.h>
 
 /*
  * Linked list of units (strings and files) to be compiled
@@ -92,12 +95,12 @@
  * Linked list pointer to files and pointer to current
  * next pointer.
  */
-static struct s_flist *files, **fl_nextp = &files;
+static struct s_flist *files = NULL, **fl_nextp = &files;
 
 FILE *infile;			/* Current input file */
 FILE *outfile;			/* Current output file */
 
-int aflag, eflag, nflag;
+int aflag, eflag, sed_nflag;
 int rflags = 0;
 static int rval;		/* Exit status */
 
@@ -118,11 +121,25 @@
 static void usage(void);
 
 int
-main(int argc, char *argv[])
+sed_main(int argc, char *argv[])
 {
 	int c, fflag;
 	char *temp_arg;
 
+    // init all flags:
+    aflag = eflag = sed_nflag = rflags = 0;
+    infile = NULL;
+    outfile = NULL;
+    fl_nextp = &files;
+    if (files != NULL) {
+        while (files != NULL) { struct s_flist *next = files->next; free(files); files = next; }
+    }
+    cu_nextp = &script;
+    if (script != NULL) {
+        while (script != NULL) { struct s_compunit *next = script->next; free(script); script = next; }
+    }
+    rval = 0;        /* Exit status */
+
 	(void) setlocale(LC_ALL, "");
 
 	fflag = 0;
@@ -139,7 +156,7 @@
 		case 'e':
 			eflag = 1;
 			if ((temp_arg = malloc(strlen(optarg) + 2)) == NULL)
-				err(1, "malloc");
+                fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 			strcpy(temp_arg, optarg);
 			strcat(temp_arg, "\n");
 			add_compunit(CU_STRING, temp_arg);
@@ -153,10 +170,10 @@
 			break;
 		case 'l':
 			if(setlinebuf(stdout) != 0)
-				warnx("setlinebuf() failed");
+                fprintf(stderr, "sed: setlinebuf() failed\n"); // warnx("setlinebuf() failed");
 			break;
 		case 'n':
-			nflag = 1;
+			sed_nflag = 1;
 			break;
 		default:
 		case '?':
@@ -181,9 +198,12 @@
 		add_file(NULL);
 	process();
 	cfclose(prog, NULL);
-	if (fclose(stdout))
-		err(1, "stdout");
-	exit(rval);
+	// if (fclose(stdout))
+	//	err(1, "stdout");
+	// exit(rval);
+    if ((infile != NULL) && (infile != stdin)) fclose(infile);
+    if ((outfile != NULL) && (outfile != stdout)) fclose(outfile);
+    return 0;
 }
 
 static void
@@ -192,7 +212,8 @@
 	(void)fprintf(stderr, "%s\n%s\n",
 		"usage: sed script [-Ealn] [-i extension] [file ...]",
 		"       sed [-Ealn] [-i extension] [-e script] ... [-f script_file] ... [file ...]");
-	exit(1);
+    pthread_exit(NULL);
+	// exit(1);
 }
 
 /*
@@ -220,7 +241,7 @@
 		switch (script->type) {
 		case CU_FILE:
 			if ((f = fopen(script->s, "r")) == NULL)
-				err(1, "%s", script->s);
+                fprintf(stderr, "sed: %s: %s\n", script->s, strerror(errno)); // err(1, "%s", script->s);
 			fname = script->s;
 			state = ST_FILE;
 			goto again;
@@ -239,7 +260,7 @@
 		if ((p = fgets(buf, n, f)) != NULL) {
 			linenum++;
 			if (linenum == 1 && buf[0] == '#' && buf[1] == 'n')
-				nflag = 1;
+				sed_nflag = 1;
 			if (more != NULL)
 				*more = !feof(f);
 			return (p);
@@ -250,7 +271,7 @@
 		goto again;
 	case ST_STRING:
 		if (linenum == 0 && s[0] == '#' && s[1] == 'n')
-			nflag = 1;
+			sed_nflag = 1;
 		p = buf;
 		for (;;) {
 			if (n-- <= 1) {
@@ -308,7 +329,7 @@
 		/* stdin? */
 		if (files->fname == NULL) {
 			if (inplace != NULL)
-				errx(1, "-i may not be used with stdin");
+                fprintf(stderr, "sed: -i may not be used with stdin\n"); //errx(1, "-i may not be used with stdin");
 			infile = stdin;
 			fname = "stdin";
 			outfile = stdout;
@@ -328,12 +349,13 @@
 			return (0);
 		}
 		if (infile != NULL) {
-			fclose(infile);
+			if (infile != stdin) fclose(infile);
 			if (*oldfname != '\0') {
 				if (rename(fname, oldfname) != 0) {
-					warn("rename()");
+                    fprintf(stderr, "sed: rename(): %s\n", strerror(errno)); // warn("rename()");
 					unlink(tmpfname);
-					exit(1);
+                    pthread_exit(NULL);
+					// exit(1);
 				}
 				*oldfname = '\0';
 			}
@@ -357,27 +379,32 @@
 		fname = files->fname;
 		if (inplace != NULL) {
 			if (lstat(fname, &sb) != 0)
-				err(1, "%s", fname);
+                fprintf(stderr, "sed: %s: %s\n", fname, strerror(errno)); // err(1, "%s", fname);
 			if (!(sb.st_mode & S_IFREG))
-				errx(1, "%s: %s %s", fname,
-				    "in-place editing only",
-				    "works for regular files");
+                fprintf(stderr, "sed: %s: %s %s\n", fname,
+                     "in-place editing only",
+                     "works for regular files");
+				//errx(1, "%s: %s %s", fname,
+				//    "in-place editing only",
+				//    "works for regular files");
 			if (*inplace != '\0') {
 				strlcpy(oldfname, fname,
 				    sizeof(oldfname));
 				len = strlcat(oldfname, inplace,
 				    sizeof(oldfname));
 				if (len > sizeof(oldfname))
-					errx(1, "%s: name too long", fname);
+                    fprintf(stderr, "sed: %s: name too long\n", fname);
+                // errx(1, "%s: name too long", fname);
 			}
 			len = snprintf(tmpfname, sizeof(tmpfname),
 			    "%s/.!%ld!%s", dirname(fname), (long)getpid(),
 			    basename(fname));
 			if (len >= sizeof(tmpfname))
-				errx(1, "%s: name too long", fname);
+                fprintf(stderr, "sed: %s: name too long\n", fname);
+				// errx(1, "%s: name too long", fname);
 			unlink(tmpfname);
 			if ((outfile = fopen(tmpfname, "w")) == NULL)
-				err(1, "%s", fname);
+                fprintf(stderr, "sed: %s: %s\n", fname, strerror(errno)); // err(1, "%s", fname);
 			fchown(fileno(outfile), sb.st_uid, sb.st_gid);
 			fchmod(fileno(outfile), sb.st_mode & ALLPERMS);
 			outfname = tmpfname;
@@ -386,7 +413,7 @@
 			outfname = "stdout";
 		}
 		if ((infile = fopen(fname, "r")) == NULL) {
-			warn("%s", fname);
+            fprintf(stderr, "sed: %s: %s\n", fname, strerror(errno)); // warn("%s", fname);
 			rval = 1;
 			continue;
 		}
@@ -401,7 +428,8 @@
 	 */
 	p = fgetln(infile, &len);
 	if (ferror(infile))
-		errx(1, "%s: %s", fname, strerror(errno ? errno : EIO));
+        fprintf(stderr, "sed: %s: %s\n", fname, strerror(errno ? errno : EIO));
+        // errx(1, "%s: %s", fname, strerror(errno ? errno : EIO));
 	if (len != 0 && p[len - 1] == '\n')
 		len--;
 	cspace(sp, p, len, spflag);
@@ -420,7 +448,7 @@
 	struct s_compunit *cu;
 
 	if ((cu = malloc(sizeof(struct s_compunit))) == NULL)
-		err(1, "malloc");
+        fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 	cu->type = type;
 	cu->s = s;
 	cu->next = NULL;
@@ -437,8 +465,9 @@
 	struct s_flist *fp;
 
 	if ((fp = malloc(sizeof(struct s_flist))) == NULL)
-		err(1, "malloc");
+        fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 	fp->next = NULL;
+    // That's the stuff:
 	*fl_nextp = fp;
 	fp->fname = s;
 	fl_nextp = &fp->next;
diff -Naur text_cmds-99/sed/misc.c text_cmds/sed/misc.c
--- text_cmds-99/sed/misc.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/misc.c	2018-01-10 11:31:02.000000000 +0100
@@ -49,6 +49,9 @@
 
 #include "defs.h"
 #include "extern.h"
+// iOS
+#include <errno.h>
+#include "ios_error.h"
 
 /*
  * Return a string for a regular expression error passed.  This is overkill,
@@ -65,7 +68,7 @@
 		free(oe);
 	s = regerror(errcode, preg, NULL, 0);
 	if ((oe = malloc(s)) == NULL)
-		err(1, "malloc");
+        fprintf(stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 	(void)regerror(errcode, preg, oe, s);
 	return (oe);
 }
diff -Naur text_cmds-99/sed/process.c text_cmds/sed/process.c
--- text_cmds-99/sed/process.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/process.c	2018-01-10 11:31:02.000000000 +0100
@@ -58,6 +58,7 @@
 
 #include "defs.h"
 #include "extern.h"
+#include "ios_error.h"
 
 static SPACE HS, PS, SS, YS;
 #define	pd		PS.deleted
@@ -116,7 +117,7 @@
 					if ((appends = realloc(appends,
 					    sizeof(struct s_appends) *
 					    (appendnum *= 2))) == NULL)
-						err(1, "realloc");
+                        fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); // err(1, "realloc");
 				appends[appendx].type = AP_STRING;
 				appends[appendx].s = cp->t;
 				appends[appendx].len = strlen(cp->t);
@@ -167,7 +168,7 @@
 				lputs(ps, psl);
 				break;
 			case 'n':
-				if (!nflag && !pd)
+				if (!sed_nflag && !pd)
 					OUT(ps)
 				flush_appends();
 				if (!mf_fgets(&PS, REPLACE))
@@ -198,7 +199,7 @@
 					psl = oldpsl;
 				break;
 			case 'q':
-				if (!nflag && !pd)
+				if (!sed_nflag && !pd)
 					OUT(ps)
 				flush_appends();
 				lseek(STDIN_FILENO, ftell(stdin), SEEK_SET);
@@ -208,7 +209,7 @@
 					if ((appends = realloc(appends,
 					    sizeof(struct s_appends) *
 					    (appendnum *= 2))) == NULL)
-						err(1, "realloc");
+						        fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); // err(1, "realloc");
 				appends[appendx].type = AP_FILE;
 				appends[appendx].s = cp->t;
 				appends[appendx].len = strlen(cp->t);
@@ -230,10 +231,10 @@
 				if (cp->u.fd == -1 && (cp->u.fd = open(cp->t,
 				    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
 				    DEFFILEMODE)) == -1)
-					err(1, "%s", cp->t);
+                    fprintf(stderr, "sed: %s: %s\n", cp->t, strerror(errno)); // err(1, "%s", cp->t);
 				if (write(cp->u.fd, ps, psl) != psl ||
 				    write(cp->u.fd, "\n", 1) != 1)
-					err(1, "%s", cp->t);
+                    fprintf(stderr, "sed: %s: %s\n", cp->t, strerror(errno)); // err(1, "%s", cp->t);
 				break;
 			case 'x':
 				if (hs == NULL)
@@ -256,7 +257,7 @@
 			cp = cp->next;
 		} /* for all cp */
 
-new:		if (!nflag && !pd)
+new:		if (!sed_nflag && !pd)
 			OUT(ps)
 		flush_appends();
 	} /* for all lines */
@@ -329,8 +330,10 @@
 	if (re == NULL) {
 		if (defpreg != NULL && cp->u.s->maxbref > defpreg->re_nsub) {
 			linenum = cp->u.s->linenum;
-			errx(1, "%lu: %s: \\%d not defined in the RE",
+            fprintf(stderr, "sed: %lu: %s: \\%d not defined in the RE\n",
+			// errx(1, "%lu: %s: \\%d not defined in the RE",
 					linenum, fname, cp->u.s->maxbref);
+            pthread_exit(NULL);
 		}
 	}
 	if (!regexec_e(re, s, 0, 0, psl))
@@ -414,10 +417,10 @@
 	if (cp->u.s->wfile && !pd) {
 		if (cp->u.s->wfd == -1 && (cp->u.s->wfd = open(cp->u.s->wfile,
 		    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC, DEFFILEMODE)) == -1)
-			err(1, "%s", cp->u.s->wfile);
+            fprintf(stderr, "sed: %s: %s\n", cp->u.s->wfile, strerror(errno)); // err(1, "%s", cp->u.s->wfile);
 		if (write(cp->u.s->wfd, ps, psl) != psl ||
 		    write(cp->u.s->wfd, "\n", 1) != 1)
-			err(1, "%s", cp->u.s->wfile);
+            fprintf(stderr, "sed: %s: %s\n", cp->u.s->wfile, strerror(errno)); // err(1, "%s", cp->u.s->wfile);
 	}
 	return (1);
 }
@@ -511,7 +514,10 @@
 			break;
 		}
 	if (ferror(outfile))
-		errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+    { fprintf(stderr, "sed: %s: %s\n", outfname, strerror(errno ? errno : EIO));
+        pthread_exit(NULL);
+    // errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+    }
 	appendx = sdone = 0;
 }
 
@@ -589,8 +595,11 @@
 		fprintf(outfile, "\\\n");
 	(void)fputc('$', outfile);
 	(void)fputc('\n', outfile);
-	if (ferror(outfile))
-		errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+    if (ferror(outfile)) {
+        fprintf(stderr, "sed: %s: %s\n", outfname, strerror(errno ? errno : EIO));
+        // errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+        pthread_exit(NULL);
+    }
 }
 
 static __inline int
@@ -601,7 +610,10 @@
 
 	if (preg == NULL) {
 		if (defpreg == NULL)
-			errx(1, "first RE may not be empty");
+        { fprintf(stderr, "sed: first RE may not be empty\n");
+            // errx(1, "first RE may not be empty");
+            pthread_exit(NULL);
+        }
 	} else
 		defpreg = preg;
 
@@ -617,7 +629,9 @@
 	case REG_NOMATCH:
 		return (0);
 	}
-	errx(1, "RE error: %s", strregerror(eval, defpreg));
+    fprintf(stderr, "sed: RE error: %s\n", strregerror(eval, defpreg));
+    pthread_exit(NULL);
+    // errx(1, "RE error: %s", strregerror(eval, defpreg));
 	/* NOTREACHED */
 }
 
@@ -637,9 +651,10 @@
 		sp->blen += (reqlen) + 1024;				\
 		if ((sp->space = sp->back = realloc(sp->back, sp->blen)) \
 		    == NULL)						\
-			err(1, "realloc");				\
+            fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); \
 		dst = sp->space + sp->len;				\
 	}
+    // err(1, "realloc");
 
 	dst = sp->space + sp->len;
 	while ((c = *src++) != '\0') {
@@ -683,7 +698,7 @@
 		sp->blen = tlen + 1024;
 		if ((sp->space = sp->back = realloc(sp->back, sp->blen)) ==
 		    NULL)
-			err(1, "realloc");
+			        fprintf(stderr, "sed: realloc: %s\n", strerror(errno)); // err(1, "realloc");
 	}
 
 	if (spflag == REPLACE)
@@ -705,12 +720,12 @@
 		switch(cp->code) {
 		case 's':
 			if (cp->u.s->wfd != -1 && close(cp->u.s->wfd))
-				err(1, "%s", cp->u.s->wfile);
+                fprintf(stderr, "sed: %s: %s\n", cp->u.s->wfile, strerror(errno)); // err(1, "%s", cp->u.s->wfile);
 			cp->u.s->wfd = -1;
 			break;
 		case 'w':
 			if (cp->u.fd != -1 && close(cp->u.fd))
-				err(1, "%s", cp->t);
+                fprintf(stderr, "sed: %s: %s\n", cp->t, strerror(errno)); // err(1, "%s", cp->t);
 			cp->u.fd = -1;
 			break;
 		case '{':
diff -Naur text_cmds-99/tr/str.c text_cmds/tr/str.c
--- text_cmds-99/tr/str.c	2005-08-18 23:20:18.000000000 +0200
+++ text_cmds/tr/str.c	2018-01-11 17:47:54.000000000 +0100
@@ -53,6 +53,10 @@
 #include <wctype.h>
 
 #include "extern.h"
+// iOS changes:
+#include "ios_error.h"
+#include <pthread.h>
+
 
 static int      backslash(STR *, int *);
 static int	bracket(STR *);
@@ -193,8 +197,10 @@
 	STR *s;
 {
 
-	if ((s->cclass = wctype(s->str)) == 0)
-		errx(1, "unknown class %s", s->str);
+    if ((s->cclass = wctype(s->str)) == 0) {
+		fprintf(stderr, "tr: unknown class %s\n", s->str); // errx
+        pthread_exit(NULL);
+    }
 	s->cnt = 0;
 	s->lastch = -1;		/* incremented before check in next() */
 	if (strcmp(s->str, "upper") == 0)
@@ -216,17 +222,21 @@
 
 	if (*s->str == '\\') {
 		s->equiv[0] = backslash(s, NULL);
-		if (*s->str != '=')
-			errx(1, "misplaced equivalence equals sign");
+        if (*s->str != '=') {
+			fprintf(stderr, "tr: misplaced equivalence equals sign\n"); // errx
+            pthread_exit(NULL);
+        }
 		s->str += 2;
 	} else {
 		clen = mbrtowc(&wc, s->str, MB_LEN_MAX, NULL);
 		if (clen == (size_t)-1 || clen == (size_t)-2 || clen == 0)
 			errc(1, EILSEQ, NULL);
 		s->equiv[0] = wc;
-		if (s->str[clen] != '=')
-			errx(1, "misplaced equivalence equals sign");
-		s->str += clen + 2;
+        if (s->str[clen] != '=') {
+			fprintf(stderr, "tr: misplaced equivalence equals sign\n"); // errx
+            pthread_exit(NULL);
+        }
+        s->str += clen + 2;
 	}
 
 	/*
@@ -294,8 +304,11 @@
 		s->str = savestart;
 		return (0);
 	}
-	if ((s->set = p = malloc((NCHARS_SB + 1) * sizeof(int))) == NULL)
-		err(1, "genrange() malloc");
+    if ((s->set = p = malloc((NCHARS_SB + 1) * sizeof(int))) == NULL) {
+		// err(1, "genrange() malloc");
+        fprintf(stderr, "tr: genrange() malloc: %s", strerror(errno));
+        pthread_exit(NULL);
+    }
 	for (cnt = 0; cnt < NCHARS_SB; cnt++)
 		if (charcoll((const void *)&cnt, (const void *)&(s->lastch)) >= 0 &&
 		    charcoll((const void *)&cnt, (const void *)&stopval) <= 0)
@@ -319,8 +332,11 @@
 	size_t clen;
 
 #ifndef __APPLE__
-	if (s->which == STRING1)
-		errx(1, "sequences only valid in string2");
+    if (s->which == STRING1) {
+		fprintf(stderr, "tr: sequences only valid in string2\n"); // errx
+        pthread_exit(NULL);
+    }
+        
 #endif /* !__APPLE__ */
 
 	if (*s->str == '\\')
@@ -332,8 +348,10 @@
 		s->lastch = wc;
 		s->str += clen;
 	}
-	if (*s->str != '*')
-		errx(1, "misplaced sequence asterisk");
+    if (*s->str != '*') {
+		fprintf(stderr, "tr: misplaced sequence asterisk\n"); // errx
+        pthread_exit(NULL);
+    }
 
 	switch (*++s->str) {
 	case '\\':
@@ -351,7 +369,8 @@
 				break;
 			}
 		}
-		errx(1, "illegal sequence count");
+		fprintf(stderr, "tr: illegal sequence count\n"); // errx
+        pthread_exit(NULL);
 		/* NOTREACHED */
 	}
 
diff -Naur text_cmds-99/tr/tr.c text_cmds/tr/tr.c
--- text_cmds-99/tr/tr.c	2006-04-21 01:51:01.000000000 +0200
+++ text_cmds/tr/tr.c	2018-01-11 17:58:50.000000000 +0100
@@ -61,6 +61,9 @@
 #include "cmap.h"
 #include "cset.h"
 #include "extern.h"
+// iOS changes:
+#include "ios_error.h"
+#include <errno.h>
 
 STR s1 = { STRING1, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
 STR s2 = { STRING2, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
@@ -68,15 +71,71 @@
 static struct cset *setup(char *, STR *, int, int);
 static void usage(void);
 
+static void initSTR(STR* s) {
+    s->which = STRING1;
+    s->state = NORMAL;
+    s->cnt = 0;
+    s->lastch = OOBCH;
+    s->cclass = 0;
+    s->equiv[0] = 0;
+    s->equiv[1] = OOBCH;
+    if (s->set != NULL) { free(s->set); s->set = NULL; }
+    s->str = NULL;
+}
+
+static void csnode_free(struct csnode *c) {
+    if (c == NULL) return;
+    
+    struct csnode* left = c->csn_left;
+    struct csnode* right = c->csn_right;
+    free(c); c = NULL;
+    csnode_free(left); left = NULL;
+    csnode_free(right); right = NULL;
+}
+
+static void cset_free(struct cset *t)
+{
+    if (t == NULL) return;
+    struct csclass* class = t->cs_classes;
+    while (class) { struct csclass* n = class->csc_next; free(class); class = n; }
+    t->cs_classes = NULL;
+    
+    struct csnode* root = t->cs_root;
+    csnode_free(root);
+    t->cs_root = NULL;
+}
+
+static void cmapnode_free(struct cmapnode *c) {
+    if (c == NULL) return;
+    
+    struct cmapnode* left = c->cmn_left;
+    struct cmapnode* right = c->cmn_right;
+    free(c); c = NULL;
+    cmapnode_free(left); left = NULL;
+    cmapnode_free(right); right = NULL;
+}
+
+static void cmap_free(struct cmap *m)
+{
+    if (m == NULL) return;
+    cmapnode_free(m->cm_root);
+    free(m);
+    m = NULL;
+}
+
+
 int
-main(int argc, char **argv)
+tr_main(int argc, char **argv)
 {
 	static int carray[NCHARS_SB];
 	struct cmap *map;
-	struct cset *delete, *squeeze;
+	struct cset *delete , *squeeze;
 	int n, *p;
 	int Cflag, cflag, dflag, sflag, isstring2;
 	wint_t ch, cnt, lastch;
+    
+    // iOS: reinitialize parameters:
+    initSTR(&s1); initSTR(&s2); s2.which = STRING2;
 
 	(void)setlocale(LC_ALL, "");
 
@@ -138,11 +197,13 @@
 			if (!cset_in(delete, ch) &&
 			    (lastch != ch || !cset_in(squeeze, ch))) {
 				lastch = ch;
-				(void)putwchar(ch);
+                (void)putwc(ch, stdout); // (void)putwchar(ch);
 			}
 		if (ferror(stdin))
-			err(1, NULL);
-		exit(0);
+            fprintf(stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+        cset_free(delete);
+        cset_free(squeeze);
+        pthread_exit(NULL); // exit(0);
 	}
 
 	/*
@@ -157,10 +218,11 @@
 
 		while ((ch = getwchar()) != WEOF)
 			if (!cset_in(delete, ch))
-				(void)putwchar(ch);
+				(void)putwc(ch, stdout); // (void)putwchar(ch);
 		if (ferror(stdin))
-			err(1, NULL);
-		exit(0);
+            fprintf(stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+        cset_free(delete);
+		pthread_exit(NULL); // exit(0);
 	}
 
 	/*
@@ -173,11 +235,12 @@
 		for (lastch = OOBCH; (ch = getwchar()) != WEOF;)
 			if (lastch != ch || !cset_in(squeeze, ch)) {
 				lastch = ch;
-				(void)putwchar(ch);
+				(void)putwc(ch, stdout); // (void)putwchar(ch);
 			}
 		if (ferror(stdin))
-			err(1, NULL);
-		exit(0);
+			fprintf(stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+        cset_free(squeeze);
+		pthread_exit(NULL); // exit(0);
 	}
 
 	/*
@@ -191,22 +254,30 @@
 
 	map = cmap_alloc();
 	if (map == NULL)
-		err(1, NULL);
+    { fprintf(stderr, "tr: %s\n", strerror(errno)); pthread_exit(NULL); }// err(1, NULL);
 	squeeze = cset_alloc();
 	if (squeeze == NULL)
-		err(1, NULL);
+    { fprintf(stderr, "tr: %s\n", strerror(errno)); cmap_free(map); pthread_exit(NULL); } // err(1, NULL);
 
 	s1.str = argv[0];
 
 	if (Cflag || cflag) {
 		cmap_default(map, OOBCH);
-		if ((s2.str = strdup(argv[1])) == NULL)
-			errx(1, "strdup(argv[1])");
+        if ((s2.str = strdup(argv[1])) == NULL) { // potential memory leak
+			fprintf(stderr, "tr: %s\n", "strdup(argv[1])"); // errx
+            cset_free(squeeze);
+            cmap_free(map);
+            pthread_exit(NULL);
+        }
 	} else
 		s2.str = argv[1];
 
-	if (!next(&s2))
-		errx(1, "empty string2");
+    if (!next(&s2)) {
+        fprintf(stderr, "tr: %s\n", "empty string2"); // errx
+        cset_free(squeeze);
+        cmap_free(map);
+        pthread_exit(NULL);
+    }
 
 	/*
 	 * For -s result will contain only those characters defined
@@ -323,18 +394,21 @@
 				ch = cmap_lookup(map, ch);
 			if (lastch != ch || !cset_in(squeeze, ch)) {
 				lastch = ch;
-				(void)putwchar(ch);
+				(void)putwc(ch, stdout); // (void)putwchar(ch);
 			}
 		}
 	else
 		while ((ch = getwchar()) != WEOF) {
 			if (!Cflag || iswrune(ch))
 				ch = cmap_lookup(map, ch);
-			(void)putwchar(ch);
+			(void)putwc(ch, stdout); // (void)putwchar(ch);
 		}
 	if (ferror(stdin))
-		err(1, NULL);
-	exit (0);
+		fprintf(stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+    cset_free(squeeze);
+    cmap_free(map);
+    pthread_exit(NULL);
+	// exit (0);
 }
 
 static struct cset *
@@ -344,7 +418,7 @@
 
 	cs = cset_alloc();
 	if (cs == NULL)
-		err(1, NULL);
+    { fprintf(stderr, "tr: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, NULL);
 	str->str = arg;
 	while (next(str))
 		cset_add(cs, str->lastch);
@@ -374,5 +448,5 @@
 		"       tr [-Ccu] -d string1",
 		"       tr [-Ccu] -s string1",
 		"       tr [-Ccu] -ds string1 string2");
-	exit(1);
+	pthread_exit(NULL); // exit(1);
 }
diff -Naur text_cmds-99/wc/wc.c text_cmds/wc/wc.c
--- text_cmds-99/wc/wc.c	2008-02-26 02:39:32.000000000 +0100
+++ text_cmds/wc/wc.c	2018-01-10 11:31:02.000000000 +0100
@@ -51,7 +51,7 @@
 #include <sys/stat.h>
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <locale.h>
@@ -62,24 +62,29 @@
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
+#include "ios_error.h"
 
 /* We allocte this much memory statically, and use it as a fallback for
   malloc failure, or statfs failure.  So it should be small, but not
   "too small" */
 #define SMALL_BUF_SIZE (1024 * 8)
 
-uintmax_t tlinect, twordct, tcharct;
-int doline, doword, dochar, domulti;
+static uintmax_t tlinect, twordct, tcharct;
+static int doline, doword, dochar, domulti;
 
 static int	cnt(const char *);
 static void	usage(void);
 
 int
-main(int argc, char *argv[])
+wc_main(int argc, char *argv[])
 {
 	int ch, errors, total;
 
 	(void) setlocale(LC_CTYPE, "");
+    // Initialize flags:
+    doline = doword = dochar =  domulti = 0;
+    tlinect = twordct = tcharct = 0;
+    optind = 1; opterr = 1; optreset = 1;
 
 	while ((ch = getopt(argc, argv, "clmw")) != -1)
 		switch((char)ch) {
@@ -133,6 +138,7 @@
 			(void)printf(" %7ju", tcharct);
 		(void)printf(" total\n");
 	}
+    optarg = NULL; opterr = 0; optind = 0;
 	exit(errors == 0 ? 0 : 1);
 }
 
@@ -159,7 +165,8 @@
 		fd = STDIN_FILENO;
 	} else {
 		if ((fd = open(file, O_RDONLY, 0)) < 0) {
-			warn("%s: open", file);
+            fprintf(stderr, "wc: %s: open: %s\n", file, strerror(errno));
+			// warn("%s: open", file);
 			return (1);
 		}
 	}
@@ -189,7 +196,8 @@
 	if (doline) {
 		while ((len = read(fd, buf, buf_size))) {
 			if (len == -1) {
-				warn("%s: read", file);
+                fprintf(stderr, "wc: %s: read: %s\n", file, strerror(errno));
+                // warn("%s: read", file);
 				(void)close(fd);
 				return (1);
 			}
@@ -213,7 +221,8 @@
 	 */
 	if (dochar || domulti) {
 		if (fstat(fd, &sb)) {
-			warn("%s: fstat", file);
+            fprintf(stderr, "wc: %s: fstat: %s\n", file, strerror(errno));
+            // warn("%s: fstat", file);
 			(void)close(fd);
 			return (1);
 		}
@@ -231,7 +240,8 @@
 	memset(&mbs, 0, sizeof(mbs));
 	while ((len = read(fd, buf, buf_size)) != 0) {
 		if (len == -1) {
-			warn("%s: read", file);
+            fprintf(stderr, "wc: %s: read: %s\n", file, strerror(errno));
+            // warn("%s: read", file);
 			(void)close(fd);
 			return (1);
 		}
@@ -244,7 +254,8 @@
 			    (size_t)-1) {
 				if (!warned) {
 					errno = EILSEQ;
-					warn("%s", file);
+                    fprintf(stderr, "wc: %s: %s\n", file, strerror(errno));
+                    // warn("%s", file);
 					warned = 1;
 				}
 				memset(&mbs, 0, sizeof(mbs));
@@ -269,7 +280,8 @@
 	}
 	if (domulti && MB_CUR_MAX > 1)
 		if (mbrtowc(NULL, NULL, 0, &mbs) == (size_t)-1 && !warned)
-			warn("%s", file);
+            fprintf(stderr, "wc: %s: %s\n", file, strerror(errno));
+            // warn("%s", file);
 	if (doline) {
 		tlinect += linect;
 		(void)printf(" %7ju", linect);
