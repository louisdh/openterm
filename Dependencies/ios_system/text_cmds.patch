diff -Naur text_cmds-99/cat/cat.c text_cmds/cat/cat.c
--- text_cmds-99/cat/cat.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/cat/cat.c	2018-01-23 22:30:24.000000000 +0100
@@ -55,7 +55,7 @@
 #endif
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <fcntl.h>
 #include <locale.h>
 #include <stdio.h>
@@ -63,9 +63,10 @@
 #include <string.h>
 #include <unistd.h>
 #include <stddef.h>
+#include "ios_error.h"
 
-int bflag, eflag, nflag, sflag, tflag, vflag;
-int rval;
+static int bflag, eflag, nflag, sflag, tflag, vflag;
+static int rval;
 const char *filename;
 
 static void usage(void);
@@ -78,11 +79,14 @@
 #endif
 
 int
-main(int argc, char *argv[])
+cat_main(int argc, char *argv[])
 {
 	int ch;
 
 	setlocale(LC_CTYPE, "");
+    // Initialize all flags
+    bflag = eflag = nflag = sflag = tflag = vflag = 0; rval = 0;
+    optind = 1; opterr = 1; optreset = 1;
 
 	while ((ch = getopt(argc, argv, "benstuv")) != -1)
 		switch (ch) {
@@ -102,7 +106,7 @@
 			tflag = vflag = 1;	/* -t implies -v */
 			break;
 		case 'u':
-			setbuf(stdout, NULL);
+			setbuf(thread_stdout, NULL);
 			break;
 		case 'v':
 			vflag = 1;
@@ -116,16 +120,17 @@
 		scanfiles(argv, 1);
 	else
 		scanfiles(argv, 0);
-	if (fclose(stdout))
-		err(1, "stdout");
-	exit(rval);
+	// if (fclose(stdout)) err(1, "stdout");
+    optarg = NULL; opterr = 0; optind = 0;
+    return rval;
+	// exit(rval);
 	/* NOTREACHED */
 }
 
 static void
 usage(void)
 {
-	fprintf(stderr, "usage: cat [-benstuv] [file ...]\n");
+	fprintf(thread_stderr, "usage: cat [-benstuv] [file ...]\n");
 	exit(1);
 	/* NOTREACHED */
 }
@@ -142,7 +147,7 @@
 
 		if (path == NULL || strcmp(path, "-") == 0) {
 			filename = "stdin";
-			fd = STDIN_FILENO;
+			fd = fileno(thread_stdin);
 		} else {
 			filename = path;
 			fd = open(path, O_RDONLY);
@@ -152,11 +157,12 @@
 #endif
 		}
 		if (fd < 0) {
-			warn("%s", path);
+            fprintf(thread_stderr, "cat: %s: %s\n", path, strerror(errno));
+            // warn("%s", path);
 			rval = 1;
 		} else if (cooked) {
-			if (fd == STDIN_FILENO)
-				cook_cat(stdin);
+			if (fd == fileno(thread_stdin))
+				cook_cat(thread_stdin);
 			else {
 				fp = fdopen(fd, "r");
 				cook_cat(fp);
@@ -164,7 +170,7 @@
 			}
 		} else {
 			raw_cat(fd);
-			if (fd != STDIN_FILENO)
+			if (fd != fileno(thread_stdin))
 				close(fd);
 		}
 		if (path == NULL)
@@ -179,8 +185,8 @@
 	int ch, gobble, line, prev;
 
 	/* Reset EOF condition on stdin. */
-	if (fp == stdin && feof(stdin))
-		clearerr(stdin);
+	if (fp == thread_stdin && feof(thread_stdin))
+		clearerr(thread_stdin);
 
 	line = gobble = 0;
 	for (prev = '\n'; (ch = getc(fp)) != EOF; prev = ch) {
@@ -194,8 +200,8 @@
 					gobble = 0;
 			}
 			if (nflag && (!bflag || ch != '\n')) {
-				(void)fprintf(stdout, "%6d\t", ++line);
-				if (ferror(stdout))
+				(void)fprintf(thread_stdout, "%6d\t", ++line);
+				if (ferror(thread_stdout))
 					break;
 			}
 		}
@@ -226,12 +232,16 @@
 			break;
 	}
 	if (ferror(fp)) {
-		warn("%s", filename);
+        fprintf(thread_stderr, "cat: %s: %s\n", filename, strerror(errno));
+        // warn("%s", filename);
 		rval = 1;
 		clearerr(fp);
 	}
-	if (ferror(stdout))
-		err(1, "stdout");
+    if (ferror(thread_stdout)) {
+		// err(1, "stdout");
+        fprintf(thread_stderr, "cat: stdout: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 }
 
 static void
@@ -241,24 +251,36 @@
 	ssize_t nr, nw;
 	static size_t bsize;
 	static char *buf = NULL;
-	struct stat sbuf;
+	// struct stat sbuf;
 
-	wfd = fileno(stdout);
+	wfd = fileno(thread_stdout);
 	if (buf == NULL) {
-		if (fstat(wfd, &sbuf))
-			err(1, "%s", filename);
-		bsize = MAX(sbuf.st_blksize, 1024);
-		if ((buf = malloc(bsize)) == NULL)
-			err(1, "buffer");
+        // if (fstat(wfd, &sbuf))
+			// err(1, "%s", filename);
+        bsize = 1024; // MAX(sbuf.st_blksize, 1024);
+        if ((buf = malloc(bsize)) == NULL) {
+            // err(1, "buffer");
+            fprintf(thread_stderr, "cat: buffer: %s\n", strerror(errno));
+            pthread_exit(NULL);
+        }
 	}
 	while ((nr = read(rfd, buf, bsize)) > 0)
-		for (off = 0; nr; nr -= nw, off += nw)
-			if ((nw = write(wfd, buf + off, (size_t)nr)) < 0)
-				err(1, "stdout");
+        for (off = 0; nr; nr -= nw, off += nw) {
+            // We can't write to the fd of stdout, so we write to stdout
+            nw = 0; // number of bytes written
+            for (int i = 0; i < nr; i++) {
+                fputc(*(buf+off+nw), thread_stdout);
+                nw += 1;
+            }
+			// if ((nw = write(wfd, buf + off, (size_t)nr)) < 0) err(1, "stdout");
+        }
 	if (nr < 0) {
-		warn("%s", filename);
+        fprintf(thread_stderr, "cat: %s: %s\n", filename, strerror(errno));
+        // warn("%s", filename);
 		rval = 1;
 	}
+    free(buf);
+    buf = NULL;
 }
 
 #ifndef NO_UDOM_SUPPORT
@@ -298,11 +320,13 @@
 		switch(flags & O_ACCMODE) {
 		case O_RDONLY:
 			if (shutdown(fd, SHUT_WR) == -1)
-				warn(NULL);
+                fprintf(thread_stderr, "cat: %s\n", strerror(errno));
+                // warn(NULL);
 			break;
 		case O_WRONLY:
 			if (shutdown(fd, SHUT_RD) == -1)
-				warn(NULL);
+                fprintf(thread_stderr, "cat: %s\n", strerror(errno));
+				// warn(NULL);
 			break;
 		default:
 			break;
diff -Naur text_cmds-99/ed/buf.c text_cmds/ed/buf.c
--- text_cmds-99/ed/buf.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/buf.c	2018-01-23 22:30:24.000000000 +0100
@@ -33,6 +33,10 @@
 #include <sys/stat.h>
 
 #include "ed.h"
+// from ios_system:
+#include "ios_error.h"
+#include <pthread.h>
+#import <Foundation/Foundation.h>
 
 
 FILE *sfp;				/* scratch file pointer */
@@ -57,7 +61,7 @@
 	if (sfseek != lp->seek) {
 		sfseek = lp->seek;
 		if (fseeko(sfp, sfseek, SEEK_SET) < 0) {
-			fprintf(stderr, "%s\n", strerror(errno));
+			fprintf(thread_stderr, "%s\n", strerror(errno));
 			errmsg = "cannot seek temp file";
 			return NULL;
 		}
@@ -65,7 +69,7 @@
 	len = lp->len;
 	REALLOC(sfbuf, sfbufsz, len + 1, NULL);
 	if ((ct = fread(sfbuf, sizeof(char), len, sfp)) <  0 || ct != len) {
-		fprintf(stderr, "%s\n", strerror(errno));
+		fprintf(thread_stderr, "%s\n", strerror(errno));
 		errmsg = "cannot read temp file";
 		return NULL;
 	}
@@ -85,7 +89,7 @@
 	const char *s;
 
 	if ((lp = (line_t *) malloc(sizeof(line_t))) == NULL) {
-		fprintf(stderr, "%s\n", strerror(errno));
+		fprintf(thread_stderr, "%s\n", strerror(errno));
 		errmsg = "out of memory";
 		return NULL;
 	}
@@ -100,7 +104,7 @@
 	/* out of position */
 	if (seek_write) {
 		if (fseeko(sfp, (off_t)0, SEEK_END) < 0) {
-			fprintf(stderr, "%s\n", strerror(errno));
+			fprintf(thread_stderr, "%s\n", strerror(errno));
 			errmsg = "cannot seek temp file";
 			return NULL;
 		}
@@ -110,7 +114,7 @@
 	/* assert: SPL1() */
 	if ((ct = fwrite(cs, sizeof(char), len, sfp)) < 0 || ct != len) {
 		sfseek = -1;
-		fprintf(stderr, "%s\n", strerror(errno));
+		fprintf(thread_stderr, "%s\n", strerror(errno));
 		errmsg = "cannot write temp file";
 		return NULL;
 	}
@@ -183,9 +187,9 @@
 }
 
 
-extern int newline_added;
+extern __thread int newline_added;
 
-char sfn[15] = "";				/* scratch file name */
+char sfn[PATH_MAX] = "";				/* scratch file name */
 
 /* open_sbuf: open scratch file */
 int
@@ -196,7 +200,10 @@
 
 	isbinary = newline_added = 0;
 	u = umask(077);
-	strcpy(sfn, "/tmp/ed.XXXXXX");
+    // getenv($HOME) + "/tmp/" or NSString * NSTemporaryDirectory(void);
+    // the latter, I guess.
+    sprintf(sfn, "%s/ed.XXXXXX", NSTemporaryDirectory().UTF8String);
+	// strcpy(sfn, "/tmp/ed.XXXXXX");
 	if ((fd = mkstemp(sfn)) == -1 ||
 	    (sfp = fdopen(fd, "w+")) == NULL) {
 		if (fd != -1)
@@ -217,7 +224,7 @@
 {
 	if (sfp) {
 		if (fclose(sfp) < 0) {
-			fprintf(stderr, "%s: %s\n", sfn, strerror(errno));
+			fprintf(thread_stderr, "%s: %s\n", sfn, strerror(errno));
 			errmsg = "cannot close temp file";
 			return ERR;
 		}
@@ -237,7 +244,8 @@
 		fclose(sfp);
 		unlink(sfn);
 	}
-	exit(n);
+	// exit(n);
+    pthread_exit(NULL);
 }
 
 
@@ -255,11 +263,11 @@
 	   !cat
 	   hello, world
 	   EOF */
-	setbuffer(stdin, stdinbuf, 1);
+	setbuffer(thread_stdin, stdinbuf, 1);
 
 	/* Ensure stdout is line buffered. This avoids bogus delays
 	   of output if stdout is piped through utilities to a terminal. */
-	setvbuf(stdout, NULL, _IOLBF, 0);
+	setvbuf(thread_stdout, NULL, _IOLBF, 0);
 	if (open_sbuf() < 0)
 		quit(2);
 	REQUE(&buffer_head, &buffer_head);
diff -Naur text_cmds-99/ed/ed.h text_cmds/ed/ed.h
--- text_cmds-99/ed/ed.h	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/ed.h	2018-01-23 22:30:24.000000000 +0100
@@ -258,25 +258,25 @@
 long write_stream(FILE *, long, long);
 
 /* global buffers */
-extern char stdinbuf[];
-extern char *ibuf;
-extern char *ibufp;
-extern int ibufsz;
+extern __thread char stdinbuf[];
+extern __thread char *ibuf;
+extern __thread char *ibufp;
+extern __thread int ibufsz;
 
 /* global flags */
-extern int isbinary;
-extern int isglobal;
-extern int modified;
-extern int mutex;
-extern int sigflags;
+extern __thread int isbinary;
+extern __thread int isglobal;
+extern __thread int modified;
+extern __thread int mutex;
+extern __thread int sigflags;
 
 /* global vars */
-extern long addr_last;
-extern long current_addr;
-extern const char *errmsg;
-extern long first_addr;
-extern int lineno;
-extern long second_addr;
-extern long u_addr_last;
-extern long u_current_addr;
-extern int posixly_correct;
+extern __thread long addr_last;
+extern __thread long current_addr;
+extern __thread const char *errmsg;
+extern __thread long first_addr;
+extern __thread int ed_lineno;
+extern __thread long second_addr;
+extern __thread long u_addr_last;
+extern __thread long u_current_addr;
+extern __thread int posixly_correct;
diff -Naur text_cmds-99/ed/glbl.c text_cmds/ed/glbl.c
--- text_cmds-99/ed/glbl.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/glbl.c	2018-01-23 22:30:24.000000000 +0100
@@ -34,6 +34,7 @@
 #include <sys/wait.h>
 
 #include "ed.h"
+#include "ios_error.h"
 
 
 /* build_active_list:  add line matching a pattern to the global-active list */
@@ -101,7 +102,7 @@
 				return ERR;
 			while ((n = get_tty_line()) > 0 &&
 			    ibuf[n - 1] != '\n')
-				clearerr(stdin);
+				clearerr(thread_stdin);
 			if (n < 0)
 				return ERR;
 			else if (n == 0) {
@@ -154,7 +155,7 @@
 #endif
 			if ((ts = (line_t **) realloc(active_list,
 			    (ti += MINBUFSZ) * sizeof(line_t **))) == NULL) {
-				fprintf(stderr, "%s\n", strerror(errno));
+				fprintf(thread_stderr, "%s\n", strerror(errno));
 				errmsg = "out of memory";
 				SPL0();
 				return ERR;
@@ -163,7 +164,7 @@
 		} else {
 			if ((ts = (line_t **) malloc((ti += MINBUFSZ) *
 			    sizeof(line_t **))) == NULL) {
-				fprintf(stderr, "%s\n", strerror(errno));
+				fprintf(thread_stderr, "%s\n", strerror(errno));
 				errmsg = "out of memory";
 				SPL0();
 				return ERR;
diff -Naur text_cmds-99/ed/io.c text_cmds/ed/io.c
--- text_cmds-99/ed/io.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/io.c	2018-01-23 22:30:24.000000000 +0100
@@ -29,9 +29,10 @@
 __FBSDID("$FreeBSD: src/bin/ed/io.c,v 1.14 2003/01/01 18:48:39 schweikh Exp $");
 
 #include "ed.h"
+#include "ios_error.h"
 
 
-extern int scripted;
+extern __thread int scripted;
 
 /* read_file: read a named file/pipe into the buffer; return line count */
 long
@@ -43,26 +44,26 @@
 
 	fp = (*fn == '!') ? popen(fn + 1, "r") : fopen(strip_escapes(fn), "r");
 	if (fp == NULL) {
-		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
+		fprintf(thread_stderr, "%s: %s\n", fn, strerror(errno));
 		errmsg = "cannot open input file";
 		return ERR;
 	} else if ((size = read_stream(fp, n)) < 0)
 		return ERR;
 	 else if (((*fn == '!') ?  pclose(fp) : fclose(fp)) < 0) {
-		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
+		fprintf(thread_stderr, "%s: %s\n", fn, strerror(errno));
 		errmsg = "cannot close input file";
 		return ERR;
 	}
-	fprintf(stdout, !scripted ? "%lu\n" : "", size);
+	fprintf(thread_stdout, !scripted ? "%lu\n" : "", size);
 	return current_addr - n;
 }
 
 
-extern int des;
+extern __thread int des;
 
 char *sbuf;			/* file i/o buffer */
 int sbufsz;			/* file i/o buffer size */
-int newline_added;		/* if set, newline appended to input file */
+__thread int newline_added;		/* if set, newline appended to input file */
 
 /* read_stream: read a stream into the editor buffer; return status */
 long
@@ -98,9 +99,9 @@
 	if (len < 0)
 		return ERR;
 	if (appended && size && o_isbinary && o_newline_added)
-		fputs("newline inserted\n", stderr);
+		fputs("newline inserted\n", thread_stderr);
 	else if (newline_added && (!appended || (!isbinary && !o_isbinary)))
-		fputs("newline appended\n", stderr);
+		fputs("newline appended\n", thread_stderr);
 	if (isbinary && newline_added && !appended)
 	    	size += 1;
 	if (!size)
@@ -130,7 +131,7 @@
 	if (c == '\n')
 		sbuf[i++] = c;
 	else if (ferror(fp)) {
-		fprintf(stderr, "%s\n", strerror(errno));
+		fprintf(thread_stderr, "%s\n", strerror(errno));
 		errmsg = "cannot read input file";
 		return ERR;
 	} else if (i) {
@@ -151,17 +152,17 @@
 
 	fp = (*fn == '!') ? popen(fn+1, "w") : fopen(strip_escapes(fn), mode);
 	if (fp == NULL) {
-		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
+		fprintf(thread_stderr, "%s: %s\n", fn, strerror(errno));
 		errmsg = "cannot open output file";
 		return ERR;
 	} else if ((size = write_stream(fp, n, m)) < 0)
 		return ERR;
 	 else if (((*fn == '!') ?  pclose(fp) : fclose(fp)) < 0) {
-		fprintf(stderr, "%s: %s\n", fn, strerror(errno));
+		fprintf(thread_stderr, "%s: %s\n", fn, strerror(errno));
 		errmsg = "cannot close output file";
 		return ERR;
 	}
-	fprintf(stdout, !scripted ? "%lu\n" : "", size);
+	fprintf(thread_stdout, !scripted ? "%lu\n" : "", size);
 	return n ? m - n + 1 : 0;
 }
 
@@ -201,7 +202,7 @@
 {
 	while (len--)
 		if ((des ? put_des_char(*s++, fp) : fputc(*s++, fp)) < 0) {
-			fprintf(stderr, "%s\n", strerror(errno));
+			fprintf(thread_stderr, "%s\n", strerror(errno));
 			errmsg = "cannot write file";
 			return ERR;
 		}
@@ -267,19 +268,19 @@
 			if (!(ibuf[i++] = c)) isbinary = 1;
 			if (c != '\n')
 				continue;
-			lineno++;
+			ed_lineno++;
 			ibuf[i] = '\0';
 			ibufp = ibuf;
 			return i;
 		case EOF:
-			if (ferror(stdin)) {
-				fprintf(stderr, "stdin: %s\n", strerror(errno));
+			if (ferror(thread_stdin)) {
+				fprintf(thread_stderr, "stdin: %s\n", strerror(errno));
 				errmsg = "cannot read stdin";
-				clearerr(stdin);
+				clearerr(thread_stdin);
 				ibufp = NULL;
 				return ERR;
 			} else {
-				clearerr(stdin);
+				clearerr(thread_stdin);
 				if (i != oi) {
 					oi = i;
 					continue;
@@ -296,8 +297,8 @@
 #define ESCAPES "\a\b\f\n\r\t\v\\"
 #define ESCCHARS "abfnrtv\\"
 
-extern int rows;
-extern int cols;
+extern __thread int rows;
+extern __thread int cols;
 
 /* put_tty_line: print text to stdout */
 int
@@ -307,12 +308,12 @@
 	char *cp;
 
 	if ((gflag & GNP) && !(gflag & GINT)) {
-		printf("%ld\t", n);
+		fprintf(thread_stdout, "%ld\t", n);
 		col = 8;
 	}
 	for (; l--; s++) {
 		if ((gflag & GLS) && ++col > cols) {
-			fputs("\\\n", stdout);
+			fputs("\\\n", thread_stdout);
 			col = 1;
 		}
 		if (gflag & GLS) {
diff -Naur text_cmds-99/ed/main.c text_cmds/ed/main.c
--- text_cmds-99/ed/main.c	2006-04-21 01:51:01.000000000 +0200
+++ text_cmds/ed/main.c	2018-01-23 22:30:24.000000000 +0100
@@ -59,14 +59,16 @@
 #include <pwd.h>
 #include <setjmp.h>
 
-#ifdef __APPLE__
-#include <get_compat.h>
-#else
+// #ifdef __APPLE__
+// #include <get_compat.h>
+// #else
 #define COMPAT_MODE(a,b) (1)
-#endif /* __APPLE__ */
+// #endif /* __APPLE__ */
 
 #include "ed.h"
-
+// from ios_system:
+#include "ios_error.h"
+#include <pthread.h>
 
 #ifdef _POSIX_SOURCE
 sigjmp_buf env;
@@ -75,43 +77,71 @@
 #endif
 
 /* static buffers */
-char stdinbuf[1];		/* stdin buffer */
-char *shcmd;			/* shell command buffer */
-int shcmdsz;			/* shell command buffer size */
-int shcmdi;			/* shell command buffer index */
-char *ibuf;			/* ed command-line buffer */
-int ibufsz;			/* ed command-line buffer size */
-char *ibufp;			/* pointer to ed command-line buffer */
+__thread char stdinbuf[1];		/* stdin buffer */
+static char *shcmd;			/* shell command buffer */
+static int shcmdsz;			/* shell command buffer size */
+static int shcmdi;			/* shell command buffer index */
+__thread char *ibuf;			/* ed command-line buffer */
+__thread int ibufsz;			/* ed command-line buffer size */
+__thread char *ibufp;			/* pointer to ed command-line buffer */
 
 /* global flags */
-int des = 0;			/* if set, use crypt(3) for i/o */
-int garrulous = 0;		/* if set, print all error messages */
-int isbinary;			/* if set, buffer contains ASCII NULs */
-int isglobal;			/* if set, doing a global command */
-int modified;			/* if set, buffer modified since last write */
-int mutex = 0;			/* if set, signals set "sigflags" */
-int red = 0;			/* if set, restrict shell/directory access */
-int scripted = 0;		/* if set, suppress diagnostics */
-int sigflags = 0;		/* if set, signals received while mutex set */
-int sigactive = 0;		/* if set, signal handlers are enabled */
-int posixly_correct = 0;	/* if set, POSIX behavior as per */
+__thread int des = 0;			/* if set, use crypt(3) for i/o */
+static int garrulous = 0;		/* if set, print all error messages */
+__thread int isbinary;			/* if set, buffer contains ASCII NULs */
+__thread int isglobal;			/* if set, doing a global command */
+__thread int modified;			/* if set, buffer modified since last write */
+__thread int mutex = 0;			/* if set, signals set "sigflags" */
+static int red = 0;			/* if set, restrict shell/directory access */
+__thread int scripted = 0;		/* if set, suppress diagnostics */
+__thread int sigflags = 0;		/* if set, signals received while mutex set */
+static int sigactive = 0;		/* if set, signal handlers are enabled */
+__thread int posixly_correct = 0;	/* if set, POSIX behavior as per */
 /* http://www.opengroup.org/onlinepubs/009695399/utilities/ed.html */
 
-char old_filename[PATH_MAX + 1] = "";	/* default filename */
-long current_addr;		/* current address in editor buffer */
-long addr_last;			/* last address in editor buffer */
-int lineno;			/* script line number */
-const char *prompt;		/* command-line prompt */
-const char *dps = "*";		/* default command-line prompt */
+static char old_filename[PATH_MAX + 1] = "";	/* default filename */
+__thread long current_addr;		/* current address in editor buffer */
+__thread long addr_last;			/* last address in editor buffer */
+__thread int ed_lineno;			/* script line number */
+static const char *prompt;		/* command-line prompt */
+static const char *dps = "*";		/* default command-line prompt */
 
-const char usage[] = "usage: %s [-] [-sx] [-p string] [file]\n";
+static const char ed_usage[] = "usage: %s [-] [-sx] [-p string] [file]\n";
 
 /* ed: line editor */
 int
-main(int argc, char *argv[])
+ed_main(int argc, char *argv[])
 {
 	int c, n;
 	long status = 0;
+    // iOS: init all flags and variables:
+    /* global flags */
+    des = 0;            /* if set, use crypt(3) for i/o */
+    garrulous = 0;        /* if set, print all error messages */
+    isbinary = 0;            /* if set, buffer contains ASCII NULs */
+    isglobal = 0;            /* if set, doing a global command */
+    modified = 0;            /* if set, buffer modified since last write */
+    mutex = 0;            /* if set, signals set "sigflags" */
+    red = 0;            /* if set, restrict shell/directory access */
+    scripted = 0;        /* if set, suppress diagnostics */
+    sigflags = 0;        /* if set, signals received while mutex set */
+    sigactive = 0;        /* if set, signal handlers are enabled */
+    posixly_correct = 0;    /* if set, POSIX behavior as per */
+    /* http://www.opengroup.org/onlinepubs/009695399/utilities/ed.html */
+    
+    old_filename[0] = 0x0;    /* default filename */
+    current_addr = 0;        /* current address in editor buffer */
+    addr_last = 0;            /* last address in editor buffer */
+    ed_lineno = 0;            /* script line number */
+    prompt = 0;        /* command-line prompt */
+    shcmd = 0;            /* shell command buffer */
+    shcmdsz = 0;            /* shell command buffer size */
+    shcmdi = 0;            /* shell command buffer index */
+    ibufÂ = 0;            /* ed command-line buffer */
+    ibufsz = 0;            /* ed command-line buffer size */
+    ibufp = 0;            /* pointer to ed command-line buffer */
+
+    
 #if __GNUC__
 	/* Avoid longjmp clobbering */
 	(void) &argc;
@@ -136,13 +166,14 @@
 #ifdef DES
 			des = get_keyword();
 #else
-			fprintf(stderr, "crypt unavailable\n?\n");
+			fprintf(thread_stderr, "crypt unavailable\n?\n");
 #endif
 			break;
 
 		default:
-			fprintf(stderr, usage, red ? "red" : "ed");
-			exit(1);
+			fprintf(thread_stderr, ed_usage, red ? "red" : "ed");
+            pthread_exit(NULL);
+			// exit(1);
 		}
 	argv += optind;
 	argc -= optind;
@@ -158,7 +189,9 @@
 	/* assert: reliable signals! */
 #ifdef SIGWINCH
 	handle_winch(SIGWINCH);
-	if (isatty(0)) signal(SIGWINCH, handle_winch);
+//	if (isatty(0)) signal(SIGWINCH, handle_winch);
+//  also replaced 6x !isatty(0) below
+    if (fileno(thread_stdin) == fileno(stdin)) signal(SIGWINCH, handle_winch);
 #endif
 	signal(SIGHUP, signal_hup);
 	signal(SIGQUIT, SIG_IGN);
@@ -169,51 +202,51 @@
 	if ((status = setjmp(env)))
 #endif
 	{
-		fputs("\n?\n", stderr);
+		fputs("\n?\n", thread_stderr);
 		errmsg = "interrupt";
 	} else {
 		init_buffers();
 		sigactive = 1;			/* enable signal handlers */
 		if (argc>0 && *argv && is_legal_filename(*argv)) {
-			if (read_file(*argv, 0) < 0 && !isatty(0))
+			if (read_file(*argv, 0) < 0 && !(fileno(thread_stdin) == fileno(stdin)))
 				quit(2);
 			else if (**argv != '!') {
 				if (strlen(*argv) < sizeof(old_filename)) {
 					strcpy(old_filename, *argv);
 				} else {
-					fprintf(stderr, "%s: filename too long\n", *argv);
+					fprintf(thread_stderr, "%s: filename too long\n", *argv);
 					quit(2);
 				}
 			}
 		} else if (argc>0) {
-			fputs("?\n", stdout);
+			fputs("?\n", thread_stdout);
 			if (**argv == '\0')
 				errmsg = "invalid filename";
-			if (!isatty(0))
+			if (!(fileno(thread_stdin) == fileno(stdin)))
 				quit(2);
 		}
 	}
 	for (;;) {
 		if (status < 0 && garrulous)
-			fprintf(stderr, "%s\n", errmsg);
+			fprintf(thread_stderr, "%s\n", errmsg);
 		if (prompt) {
-			printf("%s", prompt);
-			fflush(stdout);
+			fprintf(thread_stdout, "%s", prompt);
+			fflush(thread_stdout);
 		}
 		if ((n = get_tty_line()) < 0) {
 			status = ERR;
 			continue;
 		} else if (n == 0) {
 			if (modified && !scripted) {
-				fputs("?\n", stderr);
+				fputs("?\n", thread_stderr);
 				errmsg = "warning: file modified";
-				if (!isatty(0)) {
-					fprintf(stderr, garrulous ?
+				if (!(fileno(thread_stdin) == fileno(stdin))) {
+					fprintf(thread_stderr, garrulous ?
 					    "script, line %d: %s\n" :
-					    "", lineno, errmsg);
+					    "", ed_lineno, errmsg);
 					quit(2);
 				}
-				clearerr(stdin);
+				clearerr(thread_stdin);
 				modified = 0;
 				status = EMOD;
 				continue;
@@ -222,7 +255,7 @@
 		} else if (ibuf[n - 1] != '\n') {
 			/* discard line */
 			errmsg = "unexpected end-of-file";
-			clearerr(stdin);
+			clearerr(thread_stdin);
 			status = ERR;
 			continue;
 		}
@@ -238,30 +271,30 @@
 			quit(0);
 		case EMOD:
 			modified = 0;
-			fputs("?\n", stderr);		/* give warning */
+			fputs("?\n", thread_stderr);		/* give warning */
 			errmsg = "warning: file modified";
-			if (!isatty(0)) {
-				fprintf(stderr, garrulous ?
+			if (!(fileno(thread_stdin) == fileno(stdin))) {
+				fprintf(thread_stderr, garrulous ?
 				    "script, line %d: %s\n" :
-				    "", lineno, errmsg);
+				    "", ed_lineno, errmsg);
 				quit(2);
 			}
 			break;
 		case FATAL:
-			if (!isatty(0))
-				fprintf(stderr, garrulous ?
+			if (!(fileno(thread_stdin) == fileno(stdin)))
+				fprintf(thread_stderr, garrulous ?
 				    "script, line %d: %s\n" : "",
-				    lineno, errmsg);
+				    ed_lineno, errmsg);
 			else
-				fprintf(stderr, garrulous ? "%s\n" : "",
+				fprintf(thread_stderr, garrulous ? "%s\n" : "",
 				    errmsg);
 			quit(3);
 		default:
-			fputs("?\n", stdout);
-			if (!isatty(0)) {
-				fprintf(stderr, garrulous ?
+			fputs("?\n", thread_stdout);
+			if (!(fileno(thread_stdin) == fileno(stdin))) {
+				fprintf(thread_stderr, garrulous ?
 				    "script, line %d: %s\n" : "",
-				    lineno, errmsg);
+				    ed_lineno, errmsg);
 				quit(2);
 			}
 			break;
@@ -270,7 +303,7 @@
 	/*NOTREACHED*/
 }
 
-long first_addr, second_addr, addr_cnt;
+__thread long first_addr, second_addr, addr_cnt;
 
 /* extract_addr_range: get line addresses from the command buffer until an
    illegal address is seen; return status */
@@ -440,9 +473,9 @@
 #define SGR 004		/* use last regex instead of last pat */
 #define SGF 010		/* repeat last substitution */
 
-int patlock = 0;	/* if set, pattern not freed by get_compiled_pattern() */
+__thread int patlock = 0;	/* if set, pattern not freed by get_compiled_pattern() */
 
-long rows = 22;		/* scroll length: ws_row - 2 */
+__thread long rows = 22;		/* scroll length: ws_row - 2 */
 
 /* exec_command: execute the next command in command buffer; return print
    request, if any */
@@ -519,7 +552,7 @@
 			if (strlen(fnp) < sizeof(old_filename)) {
 				strcpy(old_filename, fnp);
 			} else {
-				fprintf(stderr, "%s: filename too long\n", fnp);
+				fprintf(thread_stderr, "%s: filename too long\n", fnp);
 				quit(2);
 			}
 		}
@@ -552,11 +585,11 @@
 			if (strlen(fnp) < sizeof(old_filename)) {
 				strcpy(old_filename, fnp);
 			} else {
-				fprintf(stderr, "%s: filename too long\n", fnp);
+				fprintf(thread_stderr, "%s: filename too long\n", fnp);
 				quit(2);
 			}
 		}
-		printf("%s\n", strip_escapes(old_filename));
+		fprintf(thread_stdout, "%s\n", strip_escapes(old_filename));
 		break;
 	case 'g':
 	case 'v':
@@ -584,7 +617,7 @@
 			return ERR;
 		}
 		GET_COMMAND_SUFFIX();
-		if (*errmsg) fprintf(stderr, "%s\n", errmsg);
+		if (*errmsg) fprintf(thread_stderr, "%s\n", errmsg);
 		break;
 	case 'H':
 		if (addr_cnt > 0) {
@@ -593,7 +626,7 @@
 		}
 		GET_COMMAND_SUFFIX();
 		if ((garrulous = 1 - garrulous) && *errmsg)
-			fprintf(stderr, "%s\n", errmsg);
+			fprintf(thread_stderr, "%s\n", errmsg);
 		break;
 	case 'i':
 		if (second_addr == 0) {
@@ -693,7 +726,7 @@
 			if (strlen(fnp) < sizeof(old_filename)) {
 				strcpy(old_filename, fnp);
 			} else {
-				fprintf(stderr, "%s: filename too long\n", fnp);
+				fprintf(thread_stderr, "%s: filename too long\n", fnp);
 				quit(2);
 			}
 		}
@@ -835,7 +868,7 @@
 			if  (strlen(fnp) < sizeof(old_filename)) {
 				strcpy(old_filename, fnp);
 			} else {
-				fprintf(stderr, "%s: filename too long\n", fnp);
+				fprintf(thread_stderr, "%s: filename too long\n", fnp);
 				quit(2);
 			}
 		}
@@ -877,7 +910,7 @@
 		break;
 	case '=':
 		GET_COMMAND_SUFFIX();
-		printf("%ld\n", addr_cnt ? second_addr : addr_last);
+		fprintf(thread_stdout, "%ld\n", addr_cnt ? second_addr : addr_last);
 		break;
 	case '!':
 		if (addr_cnt > 0) {
@@ -886,10 +919,10 @@
 		} else if ((sflags = get_shell_command()) < 0)
 			return ERR;
 		GET_COMMAND_SUFFIX();
-		if (sflags) printf("%s\n", shcmd + 1);
-		fflush(stdout);
-		system(shcmd + 1);
-		if (!scripted) printf("!\n");
+		if (sflags) fprintf(thread_stdout, "%s\n", shcmd + 1);
+		fflush(thread_stdout);
+		ios_system(shcmd + 1);
+		if (!scripted) fprintf(thread_stdout, "!\n");
 		break;
 	case '\n':
 		if (check_addr_range(first_addr = 1, current_addr + (posixly_correct ? !isglobal : 1)) < 0
@@ -969,7 +1002,7 @@
 			if ((n = get_shell_command()) < 0)
 				return NULL;
 			if (n)
-				printf("%s\n", shcmd + 1);
+				fprintf(thread_stdout, "%s\n", shcmd + 1);
 			return shcmd;
 		} else if (n > PATH_MAX) {
 			errmsg = "filename too long";
@@ -1065,7 +1098,7 @@
 			if ((l = get_tty_line()) < 0)
 				return ERR;
 			else if (l == 0 || ibuf[l - 1] != '\n') {
-				clearerr(stdin);
+				clearerr(thread_stdin);
 				return  l ? EOF : 0;
 			}
 			lp = ibuf;
@@ -1330,7 +1363,7 @@
 	line_t *np;
 
 	if ((np = (line_t *) malloc(sizeof(line_t))) == NULL) {
-		fprintf(stderr, "%s\n", strerror(errno));
+		fprintf(thread_stderr, "%s\n", strerror(errno));
 		errmsg = "out of memory";
 		return NULL;
 	}
@@ -1425,7 +1458,7 @@
 }
 
 
-int cols = 72;				/* wrap column */
+__thread int cols = 72;				/* wrap column */
 
 void
 handle_winch(int signo)
diff -Naur text_cmds-99/ed/re.c text_cmds/ed/re.c
--- text_cmds-99/ed/re.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/re.c	2018-01-23 22:30:24.000000000 +0100
@@ -30,11 +30,12 @@
 __FBSDID("$FreeBSD: src/bin/ed/re.c,v 1.20 2003/07/20 10:24:09 ru Exp $");
 
 #include "ed.h"
+#include "ios_error.h"
 
 
-extern int patlock;
+extern __thread int patlock;
 
-const char *errmsg = "";
+const __thread char *errmsg = "";
 
 /* get_compiled_pattern: return pointer to compiled pattern from command
    buffer */
@@ -61,7 +62,7 @@
 	if (expr && !patlock)
 		regfree(expr);
 	else if ((expr = (pattern_t *) malloc(sizeof(pattern_t))) == NULL) {
-		fprintf(stderr, "%s\n", strerror(errno));
+		fprintf(thread_stderr, "%s\n", strerror(errno));
 		errmsg = "out of memory";
 		return NULL;
 	}
diff -Naur text_cmds-99/ed/sub.c text_cmds/ed/sub.c
--- text_cmds-99/ed/sub.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/sub.c	2018-01-23 22:30:24.000000000 +0100
@@ -30,6 +30,7 @@
 __FBSDID("$FreeBSD: src/bin/ed/sub.c,v 1.15 2002/06/30 05:13:53 obrien Exp $");
 
 #include "ed.h"
+#include "ios_error.h"
 
 
 char *rhbuf;			/* rhs substitution buffer */
@@ -94,7 +95,7 @@
 		else if (!isglobal) {
 			while ((n = get_tty_line()) == 0 ||
 			    (n > 0 && ibuf[n - 1] != '\n'))
-				clearerr(stdin);
+				clearerr(thread_stdin);
 			if (n < 0)
 				return NULL;
 		}
diff -Naur text_cmds-99/ed/undo.c text_cmds/ed/undo.c
--- text_cmds-99/ed/undo.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/ed/undo.c	2018-01-23 22:30:24.000000000 +0100
@@ -29,6 +29,7 @@
 __FBSDID("$FreeBSD: src/bin/ed/undo.c,v 1.12 2002/06/30 05:13:53 obrien Exp $");
 
 #include "ed.h"
+#include "ios_error.h"
 
 
 #define USIZE 100				/* undo stack size */
@@ -45,7 +46,7 @@
 #if defined(sun) || defined(NO_REALLOC_NULL)
 	if (ustack == NULL &&
 	    (ustack = (undo_t *) malloc((usize = USIZE) * sizeof(undo_t))) == NULL) {
-		fprintf(stderr, "%s\n", strerror(errno));
+		fprintf(thread_stderr, "%s\n", strerror(errno));
 		errmsg = "out of memory";
 		return NULL;
 	}
@@ -60,7 +61,7 @@
 		return ustack + u_p++;
 	}
 	/* out of memory - release undo stack */
-	fprintf(stderr, "%s\n", strerror(errno));
+	fprintf(thread_stderr, "%s\n", strerror(errno));
 	errmsg = "out of memory";
 	clear_undo_stack();
 	free(ustack);
@@ -77,8 +78,8 @@
 }
 
 
-long u_current_addr = -1;	/* if >= 0, undo enabled */
-long u_addr_last = -1;		/* if >= 0, undo enabled */
+__thread long u_current_addr = -1;	/* if >= 0, undo enabled */
+__thread long u_addr_last = -1;		/* if >= 0, undo enabled */
 
 /* pop_undo_stack: undo last change to the editor buffer */
 int
diff -Naur text_cmds-99/grep/file.c text_cmds/grep/file.c
--- text_cmds-99/grep/file.c	2015-08-18 22:29:43.000000000 +0200
+++ text_cmds/grep/file.c	2018-01-23 22:30:24.000000000 +0100
@@ -38,7 +38,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #ifndef WITHOUT_LZMA
@@ -57,6 +57,7 @@
 #endif
 
 #include "grep.h"
+#include "ios_error.h"
 
 #define	MAXBUFSIZ	(32 * 1024)
 #define	LNBUFBUMP	80
@@ -262,7 +263,7 @@
 	if (path == NULL) {
 		/* Processing stdin implies --line-buffered. */
 		lbflag = true;
-		f->fd = STDIN_FILENO;
+		f->fd = fileno(thread_stdin);
 	} else if ((f->fd = open(path, O_RDONLY)) == -1)
 		goto error1;
 
@@ -284,6 +285,7 @@
 			fsiz = st.st_size;
 			buffer = mmap(NULL, fsiz, PROT_READ, flags,
 			     f->fd, (off_t)0);
+            fprintf(thread_stderr, "Read buffer: %s\n", buffer);
 			if (buffer == MAP_FAILED)
 				filebehave = FILE_STDIO;
 			else {
diff -Naur text_cmds-99/grep/grep.c text_cmds/grep/grep.c
--- text_cmds-99/grep/grep.c	2015-08-18 22:29:43.000000000 +0200
+++ text_cmds/grep/grep.c	2018-01-23 22:30:24.000000000 +0100
@@ -36,7 +36,7 @@
 #include <sys/types.h>
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>
@@ -53,10 +53,11 @@
 #include "fastmatch.h"
 #endif
 #include "grep.h"
+#include "ios_error.h"
 
 #ifndef WITHOUT_NLS
 #include <nl_types.h>
-nl_catd	 catalog;
+__thread nl_catd	 catalog;
 #endif
 
 /*
@@ -67,7 +68,7 @@
 	"",
 /* 1*/	"(standard input)",
 /* 2*/	"cannot read bzip2 compressed file",
-/* 3*/	"unknown %s option",
+/* 3*/	"grep: unknown %s option\n",
 #ifdef __APPLE__
 /* 4*/	"usage: %s [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]]\n",
 #else
@@ -81,60 +82,60 @@
 };
 
 /* Flags passed to regcomp() and regexec() */
-int		 cflags = REG_NOSUB;
-int		 eflags = REG_STARTEND;
+__thread int		 cflags = REG_NOSUB;
+__thread int		 eflags = REG_STARTEND;
 
 /* Shortcut for matching all cases like empty regex */
-bool		 matchall;
+__thread bool		 matchall;
 
 /* Searching patterns */
-unsigned int	 patterns, pattern_sz;
-struct pat	*pattern;
-regex_t		*r_pattern;
+unsigned __thread int	 patterns, pattern_sz;
+__thread struct pat	*pattern;
+__thread regex_t		*r_pattern;
 #ifndef WITHOUT_FASTMATCH
-fastmatch_t	*fg_pattern;
+__thread fastmatch_t	*fg_pattern;
 #endif
 
 /* Filename exclusion/inclusion patterns */
-unsigned int	 fpatterns, fpattern_sz;
-unsigned int	 dpatterns, dpattern_sz;
-struct epat	*dpattern, *fpattern;
+unsigned __thread int	 fpatterns, fpattern_sz;
+unsigned __thread int	 dpatterns, dpattern_sz;
+__thread struct epat	*dpattern, *fpattern;
 
 /* For regex errors  */
 char	 re_error[RE_ERROR_BUF + 1];
 
 /* Command-line flags */
-unsigned long long Aflag;	/* -A x: print x lines trailing each match */
-unsigned long long Bflag;	/* -B x: print x lines leading each match */
-bool	 Hflag;		/* -H: always print file name */
-bool	 Lflag;		/* -L: only show names of files with no matches */
-bool	 bflag;		/* -b: show block numbers for each match */
-bool	 cflag;		/* -c: only show a count of matching lines */
-bool	 hflag;		/* -h: don't print filename headers */
-bool	 iflag;		/* -i: ignore case */
-bool	 lflag;		/* -l: only show names of files with matches */
-bool	 mflag;		/* -m x: stop reading the files after x matches */
-long long mcount;	/* count for -m */
-bool	 nflag;		/* -n: show line numbers in front of matching lines */
-bool	 oflag;		/* -o: print only matching part */
-bool	 qflag;		/* -q: quiet mode (don't output anything) */
-bool	 sflag;		/* -s: silent mode (ignore errors) */
-bool	 vflag;		/* -v: only show non-matching lines */
-bool	 wflag;		/* -w: pattern must start and end on word boundaries */
-bool	 xflag;		/* -x: pattern must match entire line */
-bool	 lbflag;	/* --line-buffered */
-bool	 nullflag;	/* --null */
-char	*label;		/* --label */
-const char *color;	/* --color */
-int	 grepbehave = GREP_BASIC;	/* -EFGP: type of the regex */
-int	 binbehave = BINFILE_BIN;	/* -aIU: handling of binary files */
-int	 filebehave = FILE_STDIO;	/* -JZ: normal, gzip or bzip2 file */
-int	 devbehave = DEV_READ;		/* -D: handling of devices */
-int	 dirbehave = DIR_READ;		/* -dRr: handling of directories */
-int	 linkbehave = LINK_READ;	/* -OpS: handling of symlinks */
+__thread unsigned long long Aflag;	/* -A x: print x lines trailing each match */
+__thread unsigned long long Bflag;	/* -B x: print x lines leading each match */
+bool	 __thread Hflag;		/* -H: always print file name */
+bool	 __thread Lflag;		/* -L: only show names of files with no matches */
+bool	 __thread bflag;		/* -b: show block numbers for each match */
+bool	 __thread cflag;		/* -c: only show a count of matching lines */
+bool	 __thread hflag;		/* -h: don't print filename headers */
+bool	 __thread iflag;		/* -i: ignore case */
+bool	 __thread lflag;		/* -l: only show names of files with matches */
+bool	 __thread mflag;		/* -m x: stop reading the files after x matches */
+long long __thread mcount;	/* count for -m */
+bool	 __thread nflag;		/* -n: show line numbers in front of matching lines */
+bool	 __thread oflag;		/* -o: print only matching part */
+bool	 __thread qflag;		/* -q: quiet mode (don't output anything) */
+bool	 __thread sflag;		/* -s: silent mode (ignore errors) */
+bool	 __thread vflag;		/* -v: only show non-matching lines */
+bool	 __thread wflag;		/* -w: pattern must start and end on word boundaries */
+bool	 __thread xflag;		/* -x: pattern must match entire line */
+bool	 __thread lbflag;	/* --line-buffered */
+bool	 __thread nullflag;	/* --null */
+char	__thread *label;		/* --label */
+const char __thread *color;	/* --color */
+int	 __thread grepbehave = GREP_BASIC;	/* -EFGP: type of the regex */
+int	 __thread binbehave = BINFILE_BIN;	/* -aIU: handling of binary files */
+int	 __thread filebehave = FILE_STDIO;	/* -JZ: normal, gzip or bzip2 file */
+int	 __thread devbehave = DEV_READ;		/* -D: handling of devices */
+int	 __thread dirbehave = DIR_READ;		/* -dRr: handling of directories */
+int	 __thread linkbehave = LINK_READ;	/* -OpS: handling of symlinks */
 
-bool	 dexclude, dinclude;	/* --exclude-dir and --include-dir */
-bool	 fexclude, finclude;	/* --exclude and --include */
+bool	 __thread dexclude, dinclude;	/* --exclude-dir and --include-dir */
+bool	 __thread fexclude, finclude;	/* --exclude and --include */
 
 enum {
 	BIN_OPT = CHAR_MAX + 1,
@@ -153,10 +154,12 @@
 static inline const char	*init_color(const char *);
 
 /* Housekeeping */
-bool	 first = true;	/* flag whether we are processing the first match */
-bool	 prev;		/* flag whether or not the previous line matched */
-int	 tail;		/* lines left to print */
-bool	 file_err;	/* file reading error */
+__thread bool	 first = true;	/* flag whether we are processing the first match */
+__thread bool	 prev;		/* flag whether or not the previous line matched */
+__thread int	 tail;		/* lines left to print */
+__thread bool	 file_err;	/* file reading error */
+
+static char* progname;
 
 /*
  * Prints usage information and returns 2.
@@ -164,10 +167,11 @@
 static void
 usage(void)
 {
-	fprintf(stderr, getstr(4), getprogname());
-	fprintf(stderr, "%s", getstr(5));
-	fprintf(stderr, "%s", getstr(6));
-	fprintf(stderr, "%s", getstr(7));
+	// fprintf(thread_stderr, getstr(4), getprogname());
+    fprintf(thread_stderr, getstr(4), progname);
+	fprintf(thread_stderr, "%s", getstr(5));
+	fprintf(thread_stderr, "%s", getstr(6));
+	fprintf(thread_stderr, "%s", getstr(7));
 	exit(2);
 }
 
@@ -328,16 +332,22 @@
 	char *line;
 	size_t len;
 
-	if ((f = fopen(fn, "r")) == NULL)
-		err(2, "%s", fn);
+    if ((f = fopen(fn, "r")) == NULL) {
+		// err(2, "%s", fn);
+        fprintf(thread_stderr, "grep: %s: %s\n", fn, strerror(errno));
+        pthread_exit(NULL);
+    }
 	if ((fstat(fileno(f), &st) == -1) || (S_ISDIR(st.st_mode))) {
 		fclose(f);
 		return;
 	}
         while ((line = fgetln(f, &len)) != NULL)
 		add_pattern(line, line[0] == '\n' ? 0 : len);
-	if (ferror(f))
-		err(2, "%s", fn);
+    if (ferror(f)) {
+		// err(2, "%s", fn);
+        fprintf(thread_stderr, "grep: %s: %s\n", fn, strerror(errno));
+        pthread_exit(NULL);
+    }
 	fclose(f);
 }
 
@@ -351,7 +361,7 @@
 }
 
 int
-main(int argc, char *argv[])
+grep_main(int argc, char *argv[])
 {
 	char **aargv, **eargv, *eopts;
 	char *ep;
@@ -360,8 +370,37 @@
 	unsigned int aargc, eargc, i;
 	int c, lastc, needpattern, newarg, prevoptind;
 
-	setlocale(LC_ALL, "");
-
+    setlocale(LC_ALL, "");
+    // Initialize all variables and flags:
+    optind = 1; opterr = 1; optreset = 1;
+    patterns = pattern_sz = 0;
+    fpatterns = fpattern_sz = 0;
+    dpatterns = dpattern_sz = 0;
+    
+    pattern = NULL;
+    dpattern = NULL;
+    fpattern = NULL;
+    
+    cflags = REG_NOSUB;
+    eflags = REG_STARTEND;
+    
+    matchall = false;
+    
+    Aflag = Bflag = 0;
+    Hflag = Lflag = bflag = cflag = hflag = iflag = lflag = mflag = false;
+    mcount = 0;
+    nflag = oflag = qflag = sflag = vflag = wflag = xflag = lbflag = nullflag = false;
+    label = NULL;
+    grepbehave = GREP_BASIC;
+    binbehave = BINFILE_BIN;
+    filebehave = FILE_STDIO;
+    devbehave = DEV_READ;
+    dirbehave = DIR_READ;
+    linkbehave = LINK_READ;
+    
+    dexclude = dinclude = false;
+    fexclude = finclude = false;
+    
 #ifndef WITHOUT_NLS
 	catalog = catopen("grep", NL_CAT_LOCALE);
 #endif
@@ -369,7 +408,9 @@
 	/* Check what is the program name of the binary.  In this
 	   way we can have all the funcionalities in one binary
 	   without the need of scripting and using ugly hacks. */
-	pn = getprogname();
+	// pn = getprogname();
+    pn = argv[0];
+    progname = argv[0]; 
 	if (pn[0] == 'b' && pn[1] == 'z') {
 		filebehave = FILE_BZIP;
 		pn += 2;
@@ -441,7 +482,9 @@
 				Aflag = 0;
 			else if (Aflag > LLONG_MAX / 10) {
 				errno = ERANGE;
-				err(2, NULL);
+                fprintf(thread_stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+				// err(2, NULL);
 			}
 			Aflag = Bflag = (Aflag * 10) + (c - '0');
 			break;
@@ -457,11 +500,16 @@
 			errno = 0;
 			l = strtoull(optarg, &ep, 10);
 			if (((errno == ERANGE) && (l == ULLONG_MAX)) ||
-			    ((errno == EINVAL) && (l == 0)))
-				err(2, NULL);
+                ((errno == EINVAL) && (l == 0))) {
+                fprintf(thread_stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
+            }
 			else if (ep[0] != '\0') {
 				errno = EINVAL;
-				err(2, NULL);
+                fprintf(thread_stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
 			}
 			if (c == 'A')
 				Aflag = l;
@@ -484,8 +532,11 @@
 				devbehave = DEV_SKIP;
 			else if (strcasecmp(optarg, "read") == 0)
 				devbehave = DEV_READ;
-			else
-				errx(2, getstr(3), "--devices");
+            else {
+				// errx(2, getstr(3), "--devices");
+                fprintf(thread_stderr, getstr(3), "--devices");
+                pthread_exit(NULL);
+            }
 			break;
 		case 'd':
 			if (strcasecmp("recurse", optarg) == 0) {
@@ -495,8 +546,11 @@
 				dirbehave = DIR_SKIP;
 			else if (strcasecmp("read", optarg) == 0)
 				dirbehave = DIR_READ;
-			else
-				errx(2, getstr(3), "--directories");
+            else {
+				// errx(2, getstr(3), "--directories");
+                fprintf(thread_stderr, getstr(3), "--directories");
+                pthread_exit(NULL);
+            }
 			break;
 		case 'E':
 			grepbehave = GREP_EXTENDED;
@@ -533,7 +587,9 @@
 		case 'J':
 #ifdef WITHOUT_BZIP2
 			errno = EOPNOTSUPP;
-			err(2, "bzip2 support was disabled at compile-time");
+			// err(2, "bzip2 support was disabled at compile-time");
+                fprintf(thread_stderr, "grep: bzip2 support was disabled at compile-time: %s\n", strerror(errno));
+            pthread_exit(NULL);
 #endif
 			filebehave = FILE_BZIP;
 			break;
@@ -550,17 +606,24 @@
 			errno = 0;
 			mcount = strtoll(optarg, &ep, 10);
 			if (((errno == ERANGE) && (mcount == LLONG_MAX)) ||
-			    ((errno == EINVAL) && (mcount == 0)))
-				err(2, NULL);
+                ((errno == EINVAL) && (mcount == 0))) {
+                fprintf(thread_stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
+            }
 			else if (ep[0] != '\0') {
 				errno = EINVAL;
-				err(2, NULL);
+                fprintf(thread_stderr, "grep: %s\n", strerror(errno));
+                pthread_exit(NULL);
+                // err(2, NULL);
 			}
 			break;
 		case 'M':
 #ifdef WITHOUT_LZMA
 			errno = EOPNOTSUPP;
-			err(2, "lzma support was disabled at compile-time");
+			// err(2, "lzma support was disabled at compile-time");
+                fprintf(thread_stderr, "grep: lzma support was disabled at compile-time: %s\n", strerror(errno));
+            pthread_exit(NULL);
 #endif
 			filebehave = FILE_LZMA;
 			break;
@@ -602,7 +665,7 @@
 #endif
 			break;
 		case 'V':
-			printf(getstr(9), getprogname(), VERSION);
+			fprintf(thread_stdout, getstr(9), progname, VERSION);
 			exit(0);
 		case 'v':
 			vflag = true;
@@ -618,7 +681,9 @@
 		case 'X':
 #ifdef WITHOUT_LZMA
 			errno = EOPNOTSUPP;
-			err(2, "xz support was disabled at compile-time");
+			// err(2, "xz support was disabled at compile-time");
+                fprintf(thread_stderr, "grep: xz support was disabled at compile-time: %s\n", strerror(errno));
+            pthread_exit(NULL);
 #endif
 			filebehave = FILE_XZ;
 			break;
@@ -632,8 +697,11 @@
 				binbehave = BINFILE_SKIP;
 			else if (strcasecmp("text", optarg) == 0)
 				binbehave = BINFILE_TEXT;
-			else
-				errx(2, getstr(3), "--binary-files");
+            else {
+				// errx(2, getstr(3), "--binary-files");
+                fprintf(thread_stderr, getstr(3), "--binary-files");
+                pthread_exit(NULL);
+            }
 			break;
 		case COLOR_OPT:
 			color = NULL;
@@ -643,7 +711,8 @@
 				char *term;
 
 				term = getenv("TERM");
-				if (isatty(STDOUT_FILENO) && term != NULL &&
+//				if (isatty(fileno(thread_stdout)) && term != NULL &&
+                if ((fileno(thread_stdout) == fileno(stdout)) && term != NULL &&
 				    strcasecmp(term, "dumb") != 0)
 					color = init_color("01;31");
 			} else if (strcasecmp("always", optarg) == 0 ||
@@ -652,8 +721,11 @@
 				color = init_color("01;31");
 			} else if (strcasecmp("never", optarg) != 0 &&
 			    strcasecmp("none", optarg) != 0 &&
-			    strcasecmp("no", optarg) != 0)
-				errx(2, getstr(3), "--color");
+                strcasecmp("no", optarg) != 0) {
+				// errx(2, getstr(3), "--color");
+                fprintf(thread_stderr, getstr(3), "--color");
+                pthread_exit(NULL);
+            }
 			cflags &= ~REG_NOSUB;
 			break;
 		case LABEL_OPT:
@@ -748,7 +820,9 @@
 			if (c != 0) {
 				regerror(c, &r_pattern[i], re_error,
 				    RE_ERROR_BUF);
-				errx(2, "%s", re_error);
+				// errx(2, "%s", re_error);
+                fprintf(thread_stderr, "grep: %s\n", re_error);
+                pthread_exit(NULL);
 			}
 #ifndef WITHOUT_FASTMATCH
 		}
@@ -756,13 +830,16 @@
 	}
 
 	if (lbflag)
-		setlinebuf(stdout);
+		setlinebuf(thread_stdout);
 
 	if ((aargc == 0 || aargc == 1) && !Hflag)
 		hflag = true;
 
-	if (aargc == 0)
-		exit(!procfile("-"));
+    if (aargc == 0) {
+        procfile("-");
+        pthread_exit(NULL);
+		// exit(!procfile("-"));
+    }
 
 	if (dirbehave == DIR_RECURSE)
 		c = grep_tree(aargv);
diff -Naur text_cmds-99/grep/grep.h text_cmds/grep/grep.h
--- text_cmds-99/grep/grep.h	2015-08-18 22:29:43.000000000 +0200
+++ text_cmds/grep/grep.h	2018-01-23 22:30:24.000000000 +0100
@@ -45,7 +45,7 @@
 #else
 #include <nl_types.h>
 
-extern nl_catd		 catalog;
+extern __thread nl_catd		 catalog;
 #define getstr(n)	 catgets(catalog, 1, n, errstr[n])
 #endif
 
@@ -113,27 +113,27 @@
 };
 
 /* Flags passed to regcomp() and regexec() */
-extern int	 cflags, eflags;
+extern __thread int	 cflags, eflags;
 
 /* Command line flags */
-extern bool	 Eflag, Fflag, Gflag, Hflag, Lflag,
+extern __thread bool	 Eflag, Fflag, Gflag, Hflag, Lflag,
 		 bflag, cflag, hflag, iflag, lflag, mflag, nflag, oflag,
 		 qflag, sflag, vflag, wflag, xflag;
-extern bool	 dexclude, dinclude, fexclude, finclude, lbflag, nullflag;
-extern unsigned long long Aflag, Bflag;
-extern long long mcount;
-extern char	*label;
-extern const char *color;
-extern int	 binbehave, devbehave, dirbehave, filebehave, grepbehave, linkbehave;
-
-extern bool	 file_err, first, matchall, prev;
-extern int	 tail;
-extern unsigned int dpatterns, fpatterns, patterns;
-extern struct pat *pattern;
-extern struct epat *dpattern, *fpattern;
-extern regex_t	*er_pattern, *r_pattern;
+extern __thread bool	 dexclude, dinclude, fexclude, finclude, lbflag, nullflag;
+extern __thread unsigned long long Aflag, Bflag;
+extern __thread long long mcount;
+extern __thread char	*label;
+extern __thread const char *color;
+extern __thread int	 binbehave, devbehave, dirbehave, filebehave, grepbehave, linkbehave;
+
+extern __thread bool	 file_err, first, matchall, prev;
+extern __thread int	 tail;
+extern __thread unsigned int dpatterns, fpatterns, patterns;
+extern __thread struct pat *pattern;
+extern __thread struct epat *dpattern, *fpattern;
+extern __thread regex_t	*er_pattern, *r_pattern;
 #ifndef WITHOUT_FASTMATCH
-extern fastmatch_t *fg_pattern;
+extern __thread fastmatch_t *fg_pattern;
 #endif
 
 /* For regex errors  */
diff -Naur text_cmds-99/grep/util.c text_cmds/grep/util.c
--- text_cmds-99/grep/util.c	2015-09-10 22:25:31.000000000 +0200
+++ text_cmds/grep/util.c	2018-01-23 22:30:24.000000000 +0100
@@ -39,7 +39,7 @@
 #endif
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fnmatch.h>
 #include <fts.h>
@@ -59,6 +59,7 @@
 #include "fastmatch.h"
 #endif
 #include "grep.h"
+#include "ios_error.h"
 
 static int	 linesqueued;
 static int	 procline(struct str *l, int);
@@ -135,8 +136,11 @@
 
 	fts_flags |= FTS_NOSTAT | FTS_NOCHDIR;
 
-	if (!(fts = fts_open(argv, fts_flags, NULL)))
-		err(2, "fts_open");
+    if (!(fts = fts_open(argv, fts_flags, NULL))) {
+		// err(2, "fts_open");
+        fprintf(thread_stderr, "grep: fts_open: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	while ((p = fts_read(fts)) != NULL) {
 		switch (p->fts_info) {
 		case FTS_DNR:
@@ -144,7 +148,8 @@
 		case FTS_ERR:
 			file_err = true;
 			if(!sflag)
-				warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
+                fprintf(thread_stderr, "grep: %s: %s\n", p->fts_path, strerror(p->fts_errno));
+                // warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
 			break;
 		case FTS_D:
 			/* FALLTHROUGH */
@@ -156,7 +161,8 @@
 			break;
 		case FTS_DC:
 			/* Print a warning for recursive directory loop */
-			warnx("warning: %s: recursive directory loop",
+			// warnx("warning: %s: recursive directory loop",
+                fprintf(thread_stderr, "grep; warning: %s: recursive directory loop\n",
 				p->fts_path);
 			break;
 		default:
@@ -194,8 +200,10 @@
 	if (strcmp(fn, "-") == 0) {
 #ifdef __APPLE__
 		/* 4053512, 10290183 */
-		if (dirbehave == DIR_RECURSE && isatty(STDIN_FILENO)) {
-			warnx("warning: recursive search of stdin");
+		// if (dirbehave == DIR_RECURSE && isatty(fileno(thread_stdin))) {
+        if (dirbehave == DIR_RECURSE && (fileno(thread_stdin) == fileno(stdin))) {
+            fprintf(thread_stderr, "grep: warning: recursive search of stdin\n");
+            // warnx("warning: recursive search of stdin");
 		}
 #endif
 		fn = label != NULL ? label : getstr(1);
@@ -215,7 +223,8 @@
 	if (f == NULL) {
 		file_err = true;
 		if (!sflag)
-			warn("%s", fn);
+            fprintf(thread_stderr, "grep: %s: %s\n", fn, strerror(errno));
+            // warn("%s", fn);
 		return (0);
 	}
 
@@ -266,16 +275,16 @@
 	if (cflag) {
 #endif
 		if (!hflag)
-			printf("%s:", ln.file);
-		printf("%u\n", c);
+			fprintf(thread_stdout, "%s:", ln.file);
+		fprintf(thread_stdout, "%u\n", c);
 	}
 	if (lflag && !qflag && c != 0)
-		printf("%s%c", fn, nullflag ? 0 : '\n');
+		fprintf(thread_stdout, "%s%c", fn, nullflag ? 0 : '\n');
 	if (Lflag && !qflag && c == 0)
-		printf("%s%c", fn, nullflag ? 0 : '\n');
+		fprintf(thread_stdout, "%s%c", fn, nullflag ? 0 : '\n');
 	if (c && !cflag && !lflag && !Lflag &&
 	    binbehave == BINFILE_BIN && f->binary && !qflag)
-		printf(getstr(8), fn);
+		fprintf(thread_stdout, getstr(8), fn);
 
 	free(ln.file);
 	free(f);
@@ -459,11 +468,11 @@
 	if ((tail || c) && !cflag && !qflag && !lflag && !Lflag) {
 		if (c) {
 			if (!first && !prev && !tail && Aflag)
-				printf("--\n");
+				fprintf(thread_stdout, "--\n");
 			tail = Aflag;
 			if (Bflag > 0) {
 				if (!first && !prev)
-					printf("--\n");
+					fprintf(thread_stdout, "--\n");
 				printqueue();
 			}
 			linesqueued = 0;
@@ -494,8 +503,11 @@
 {
 	void *ptr;
 
-	if ((ptr = malloc(size)) == NULL)
-		err(2, "malloc");
+    if ((ptr = malloc(size)) == NULL) {
+		// err(2, "malloc");
+        fprintf(thread_stderr, "grep: malloc: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	return (ptr);
 }
 
@@ -507,8 +519,11 @@
 {
 	void *ptr;
 
-	if ((ptr = calloc(nmemb, size)) == NULL)
-		err(2, "calloc");
+    if ((ptr = calloc(nmemb, size)) == NULL) {
+        // err(2, "calloc");
+        fprintf(thread_stderr, "grep: calloc: %s\n", strerror(errno));
+    pthread_exit(NULL);
+}
 	return (ptr);
 }
 
@@ -519,8 +534,11 @@
 grep_realloc(void *ptr, size_t size)
 {
 
-	if ((ptr = realloc(ptr, size)) == NULL)
-		err(2, "realloc");
+    if ((ptr = realloc(ptr, size)) == NULL) {
+        // err(2, "realloc");
+        fprintf(thread_stderr, "grep: realloc: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	return (ptr);
 }
 
@@ -532,8 +550,11 @@
 {
 	char *ret;
 
-	if ((ret = strdup(str)) == NULL)
-		err(2, "strdup");
+    if ((ret = strdup(str)) == NULL) {
+        // err(2, "strdup");
+        fprintf(thread_stderr, "grep: strdup: %s\n", strerror(errno));
+        pthread_exit(NULL);
+    }
 	return (ret);
 }
 
@@ -548,23 +569,23 @@
 
 	if (!hflag) {
 		if (!nullflag) {
-			fputs(line->file, stdout);
+			fputs(line->file, thread_stdout);
 			++n;
 		} else {
-			printf("%s", line->file);
+			fprintf(thread_stdout, "%s", line->file);
 			putchar(0);
 		}
 	}
 	if (nflag) {
 		if (n > 0)
 			putchar(sep);
-		printf("%d", line->line_no);
+		fprintf(thread_stdout, "%d", line->line_no);
 		++n;
 	}
 	if (bflag) {
 		if (n > 0)
 			putchar(sep);
-		printf("%lld", (long long)line->off);
+		fprintf(thread_stdout, "%lld", (long long)line->off);
 		++n;
 	}
 	if (n)
@@ -574,26 +595,26 @@
 		for (i = 0; i < m; i++) {
 			if (!oflag)
 				fwrite(line->dat + a, matches[i].rm_so - a, 1,
-				    stdout);
+				    thread_stdout);
 			if (color) 
-				fprintf(stdout, "\33[%sm\33[K", color);
+				fprintf(thread_stdout, "\33[%sm\33[K", color);
 
 				fwrite(line->dat + matches[i].rm_so, 
 				    matches[i].rm_eo - matches[i].rm_so, 1,
-				    stdout);
+				    thread_stdout);
 			if (color) 
-				fprintf(stdout, "\33[m\33[K");
+				fprintf(thread_stdout, "\33[m\33[K");
 			a = matches[i].rm_eo;
 			if (oflag)
 				putchar('\n');
 		}
 		if (!oflag) {
 			if (line->len - a > 0)
-				fwrite(line->dat + a, line->len - a, 1, stdout);
+				fwrite(line->dat + a, line->len - a, 1, thread_stdout);
 			putchar('\n');
 		}
 	} else {
-		fwrite(line->dat, line->len, 1, stdout);
+		fwrite(line->dat, line->len, 1, thread_stdout);
 		putchar('\n');
 	}
 }
diff -Naur text_cmds-99/sed/compile.c text_cmds/sed/compile.c
--- text_cmds-99/sed/compile.c	2006-12-05 23:29:30.000000000 +0100
+++ text_cmds/sed/compile.c	2018-01-23 22:30:24.000000000 +0100
@@ -54,12 +54,13 @@
 
 #include "defs.h"
 #include "extern.h"
+#include "ios_error.h"
 
-#ifdef __APPLE__
-#include <get_compat.h>
-#else
+// #ifdef __APPLE__
+// #include <get_compat.h>
+// #else
 #define COMPAT_MODE(a,b) (1)
-#endif /* __APPLE__ */
+// #endif /* __APPLE__ */
 
 #define LHSZ	128
 #define	LHMASK	(LHSZ - 1)
@@ -129,7 +130,7 @@
 };
 
 /* The compiled program. */
-struct s_command *prog;
+__thread struct s_command *prog;
 
 /*
  * Compile the program into prog.
@@ -145,9 +146,9 @@
 		appends = NULL;
 	else if ((appends = malloc(sizeof(struct s_appends) * appendnum)) ==
 	    NULL)
-		err(1, "malloc");
+    { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); }Â // err(1, "malloc");
 	if ((match = malloc((maxnsub + 1) * sizeof(regmatch_t))) == NULL)
-		err(1, "malloc");
+    { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 }
 
 #define EATSPACE() do {							\
@@ -169,8 +170,11 @@
 	for (;;) {
 		if ((p = cu_fgets(lbuf, sizeof(lbuf), NULL)) == NULL) {
 			if (stack != 0)
-				errx(1, "%lu: %s: unexpected EOF (pending }'s)",
+            { fprintf(thread_stderr, "sed: %lu: %s: unexpected EOF (pending }'s)\n",
+				// errx(1, "%lu: %s: unexpected EOF (pending }'s)",
 							linenum, fname);
+                pthread_exit(NULL);
+            }
 			return (link);
 		}
 
@@ -184,7 +188,7 @@
 			}
 		}
 		if ((*link = cmd = malloc(sizeof(struct s_command))) == NULL)
-			err(1, "malloc");
+        { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 		link = &cmd->next;
 		cmd->nonsel = cmd->inrange = 0;
 		/* First parse the addresses */
@@ -195,7 +199,7 @@
 		if (addrchar(*p)) {
 			naddr++;
 			if ((cmd->a1 = malloc(sizeof(struct s_addr))) == NULL)
-				err(1, "malloc");
+            { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 			p = compile_addr(p, cmd->a1);
 			EATSPACE();				/* EXTENSION */
 			if (*p == ',') {
@@ -204,7 +208,7 @@
 				naddr++;
 				if ((cmd->a2 = malloc(sizeof(struct s_addr)))
 				    == NULL)
-					err(1, "malloc");
+                { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 				p = compile_addr(p, cmd->a2);
 				EATSPACE();
 			} else
@@ -214,17 +218,24 @@
 
 nonsel:		/* Now parse the command */
 		if (!*p)
-			errx(1, "%lu: %s: command expected", linenum, fname);
+        { fprintf(thread_stderr, "sed: %lu: %s: command expected\n", linenum, fname); pthread_exit(NULL); }
+            // errx(1, "%lu: %s: command expected", linenum, fname);
 		cmd->code = *p;
 		for (fp = cmd_fmts; fp->code; fp++)
 			if (fp->code == *p)
 				break;
 		if (!fp->code)
-			errx(1, "%lu: %s: invalid command code %c", linenum, fname, *p);
+        { fprintf(thread_stderr, "sed: %lu: %s: invalid command code %c\n", linenum, fname, *p); pthread_exit(NULL); }
+			// errx(1, "%lu: %s: invalid command code %c", linenum, fname, *p);
 		if (naddr > fp->naddr)
-			errx(1,
-				"%lu: %s: command %c expects up to %d address(es), found %d",
-				linenum, fname, *p, fp->naddr, naddr);
+        { fprintf(thread_stderr,
+                  "sed: %lu: %s: command %c expects up to %d address(es), found %d\n",
+                 linenum, fname, *p, fp->naddr, naddr);
+            pthread_exit(NULL);
+        }
+			// errx(1,
+			//	"%lu: %s: command %c expects up to %d address(es), found %d",
+			//	linenum, fname, *p, fp->naddr, naddr);
 		switch (fp->args) {
 		case NONSEL:			/* ! */
 			p++;
@@ -247,7 +258,8 @@
 			 */
 			cmd->nonsel = 1;
 			if (stack == 0)
-				errx(1, "%lu: %s: unexpected }", linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: unexpected }\n", linenum, fname); pthread_exit(NULL); }
+                // errx(1, "%lu: %s: unexpected }", linenum, fname);
 			cmd2 = stack;
 			stack = cmd2->next;
 			cmd2->next = cmd;
@@ -261,21 +273,31 @@
 				goto semicolon;
 			}
 			if (*p)
-				errx(1, "%lu: %s: extra characters at the end of %c command",
-						linenum, fname, cmd->code);
+            { fprintf(thread_stderr, "sed: %lu: %s: extra characters at the end of %c command\n", linenum, fname, cmd->code); pthread_exit(NULL); }
+				// errx(1, "%lu: %s: extra characters at the end of %c command",
+						// linenum, fname, cmd->code);
 			break;
 		case TEXT:			/* a c i */
 			p++;
 			EATSPACE();
 			if (*p != '\\')
-				errx(1,
-"%lu: %s: command %c expects \\ followed by text", linenum, fname, cmd->code);
+            { fprintf(thread_stderr,
+                      "sed: %lu: %s: command %c expects \\ followed by text\n", linenum, fname, cmd->code);
+                pthread_exit(NULL);
+            }
+				// errx(1,
+// "%lu: %s: command %c expects \\ followed by text", linenum, fname, cmd->code);
 			p++;
 			EATSPACE();
 			if (*p)
-				errx(1,
-				"%lu: %s: extra characters after \\ at the end of %c command",
-				linenum, fname, cmd->code);
+            { fprintf(thread_stderr,
+                      "sed: %lu: %s: extra characters after \\ at the end of %c command\n",
+                     linenum, fname, cmd->code);
+                pthread_exit(NULL);
+            }
+				// errx(1,
+				// "%lu: %s: extra characters after \\ at the end of %c command",
+				//linenum, fname, cmd->code);
 			cmd->t = compile_text();
 			break;
 		case COMMENT:			/* \0 # */
@@ -284,20 +306,26 @@
 			p++;
 			EATSPACE();
 			if (*p == '\0')
-				errx(1, "%lu: %s: filename expected", linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: filename expected\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+             //   errx(1, "%lu: %s: filename expected", linenum, fname);
 			cmd->t = duptoeol(p, "w command");
 			if (aflag)
 				cmd->u.fd = -1;
 			else if ((cmd->u.fd = open(p,
 			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
 			    DEFFILEMODE)) == -1)
-				err(1, "%s", p);
+            { fprintf(thread_stderr, "sed: %s: %s\n", p, strerror(errno)); pthread_exit(NULL); }  // err(1, "%s", p);
 			break;
 		case RFILE:			/* r */
 			p++;
 			EATSPACE();
 			if (*p == '\0')
-				errx(1, "%lu: %s: filename expected", linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: filename expected\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				// errx(1, "%lu: %s: filename expected", linenum, fname);
 			else
 				cmd->t = duptoeol(p, "read command");
 			break;
@@ -314,21 +342,30 @@
 			EATSPACE();
 			cmd->t = duptoeol(p, "label");
 			if (strlen(p) == 0)
-				errx(1, "%lu: %s: empty label", linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: empty label\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+			//	errx(1, "%lu: %s: empty label", linenum, fname);
 			enterlabel(cmd);
 			break;
 		case SUBST:			/* s */
 			p++;
 			if (*p == '\0' || *p == '\\')
-				errx(1,
-"%lu: %s: substitute pattern can not be delimited by newline or backslash",
-					linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: substitute pattern can not be delimited by newline or backslash\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				// errx(1,
+//"%lu: %s: substitute pattern can not be delimited by newline or backslash",
+	//				linenum, fname);
 			if ((cmd->u.s = malloc(sizeof(struct s_subst))) == NULL)
-				err(1, "malloc");
+            { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 			p = compile_re(p, &cmd->u.s->re);
 			if (p == NULL)
-				errx(1,
-				"%lu: %s: unterminated substitute pattern", linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: unterminated substitute pattern\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				//errx(1,
+				// "%lu: %s: unterminated substitute pattern", linenum, fname);
 			--p;
 			p = compile_subst(p, cmd->u.s);
 			p = compile_flags(p, cmd->u.s);
@@ -349,8 +386,12 @@
 				goto semicolon;
 			}
 			if (*p)
-				errx(1,
-"%lu: %s: extra text at the end of a transform command", linenum, fname);
+            { fprintf(thread_stderr,
+                      "sed: %lu: %s: extra text at the end of a transform command\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+				//errx(1,
+//"%lu: %s: extra text at the end of a transform command", linenum, fname);
 			break;
 		}
 	}
@@ -374,15 +415,24 @@
 	if (c == '\0')
 		return (NULL);
 	else if (c == '\\')
-		errx(1, "%lu: %s: \\ can not be used as a string delimiter",
+    { fprintf(thread_stderr, "sed: %lu: %s: \\ can not be used as a string delimiter\n",
+             //errx(1, "%lu: %s: \\ can not be used as a string delimiter",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	else if (c == '\n')
-		errx(1, "%lu: %s: newline can not be used as a string delimiter",
+    { fprintf(thread_stderr, "sed: %lu: %s: newline can not be used as a string delimiter\n",
+              // errx(1, "%lu: %s: newline can not be used as a string delimiter",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	while (*p) {
 		if (*p == '[' && c != *p) {
 			if ((d = compile_ccl(&p, d)) == NULL)
-				errx(1, "%lu: %s: unbalanced brackets ([])", linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: unbalanced brackets ([])", linenum, fname);
+				//errx(1, "%lu: %s: unbalanced brackets ([])", linenum, fname);
+                pthread_exit(NULL);
+            }
 			continue;
 		} else if (*p == '\\' && p[1] == '[') {
 			*d++ = *p++;
@@ -451,10 +501,13 @@
 		return (p);
 	}
 	if ((*repp = malloc(sizeof(regex_t))) == NULL)
-		err(1, "malloc");
+    { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	if (p && (eval = regcomp(*repp, re, rflags)) != 0)
-		errx(1, "%lu: %s: RE error: %s",
+    { fprintf(thread_stderr, "sed: %lu: %s: RE error: %s\n",
+		// errx(1, "%lu: %s: RE error: %s",
 				linenum, fname, strregerror(eval, *repp));
+        pthread_exit(NULL);
+    }
 	if (maxnsub < (*repp)->re_nsub)
 		maxnsub = (*repp)->re_nsub;
 	return (p);
@@ -482,7 +535,7 @@
 	s->linenum = linenum;
 	asize = 2 * _POSIX2_LINE_MAX + 1;
 	if ((text = malloc(asize)) == NULL)
-		err(1, "malloc");
+    { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	size = 0;
 	do {
 		op = sp = text + size;
@@ -514,8 +567,11 @@
 					ref = *p - '0';
 					if (s->re != NULL &&
 					    ref > s->re->re_nsub)
-						errx(1, "%lu: %s: \\%c not defined in the RE",
+                    { fprintf(thread_stderr, "sed: %lu: %s: \\%c not defined in the RE\n",
+						// errx(1, "%lu: %s: \\%c not defined in the RE",
 								linenum, fname, *p);
+                        pthread_exit(NULL);
+                    }
 					if (s->maxbref < ref)
 						s->maxbref = ref;
 				} else if (*p == '&' || *p == '\\')
@@ -528,11 +584,13 @@
 				*sp++ = '\0';
 				size += sp - op;
 				if ((s->new = realloc(text, size)) == NULL)
-					err(1, "realloc");
+                { fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 				return (p);
 			} else if (*p == '\n') {
-				errx(1,
-"%lu: %s: unescaped newline inside substitute pattern", linenum, fname);
+				fprintf(thread_stderr,
+                    // errx(1,
+                        "sed: %lu: %s: unescaped newline inside substitute pattern\n", linenum, fname);
+                pthread_exit(NULL);
 				/* NOTREACHED */
 			}
 			*sp++ = *p;
@@ -541,11 +599,13 @@
 		if (asize - size < _POSIX2_LINE_MAX + 1) {
 			asize *= 2;
 			if ((text = realloc(text, asize)) == NULL)
-				err(1, "realloc");
+            {Â fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 		}
 	} while (cu_fgets(p = lbuf, sizeof(lbuf), &more));
-	errx(1, "%lu: %s: unterminated substitute in regular expression",
+    fprintf(thread_stderr, "sed: %lu: %s: unterminated substitute in regular expression\n",
+         // errx(1, "%lu: %s: unterminated substitute in regular expression",
 			linenum, fname);
+    pthread_exit(NULL);
 	/* NOTREACHED */
 }
 
@@ -568,8 +628,11 @@
 		switch (*p) {
 		case 'g':
 			if (gn)
-				errx(1,
-"%lu: %s: more than one number or 'g' in substitute flags", linenum, fname);
+            { fprintf(thread_stderr,
+                     //errx(1,
+                      "sed: %lu: %s: more than one number or 'g' in substitute flags\n", linenum, fname);
+                pthread_exit(NULL);
+            }
 			gn = 1;
 			s->n = 0;
 			break;
@@ -584,14 +647,20 @@
 		case '4': case '5': case '6':
 		case '7': case '8': case '9':
 			if (gn)
-				errx(1,
-"%lu: %s: more than one number or 'g' in substitute flags", linenum, fname);
+            { fprintf(thread_stderr,
+				// errx(1,
+                      "sed: %lu: %s: more than one number or 'g' in substitute flags\n", linenum, fname);
+                pthread_exit(NULL);
+            }
 			gn = 1;
 			errno = 0;
 			nval = strtol(p, &p, 10);
 			if (errno == ERANGE || nval > INT_MAX)
-				errx(1,
-"%lu: %s: overflow in the 'N' substitute flag", linenum, fname);
+            { fprintf(thread_stderr,
+				//errx(1,
+                      "sed: %lu: %s: overflow in the 'N' substitute flag\n", linenum, fname);
+                pthread_exit(NULL);
+            }
 			s->n = nval;
 			p--;
 			break;
@@ -599,7 +668,8 @@
 			p++;
 #ifdef HISTORIC_PRACTICE
 			if (*p != ' ') {
-				warnx("%lu: %s: space missing before w wfile", linenum, fname);
+                fprintf(stder, "sed: %lu: %s: space missing before w wfile\n", linenum, fname);
+				// warnx("%lu: %s: space missing before w wfile", linenum, fname);
 				return (p);
 			}
 #endif
@@ -612,16 +682,21 @@
 			}
 			*q = '\0';
 			if (q == wfile)
-				errx(1, "%lu: %s: no wfile specified", linenum, fname);
+            { fprintf(thread_stderr, "sed: %lu: %s: no wfile specified\n", linenum, fname);
+                pthread_exit(NULL);
+            }
+                // errx(1, "%lu: %s: no wfile specified", linenum, fname);
 			s->wfile = strdup(wfile);
 			if (!aflag && (s->wfd = open(wfile,
 			    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
 			    DEFFILEMODE)) == -1)
-				err(1, "%s", wfile);
+            { fprintf(thread_stderr, "sed: %s: %s\n", wfile, strerror(errno)); pthread_exit(NULL); } // err(1, "%s", wfile);
 			return (p);
 		default:
-			errx(1, "%lu: %s: bad flag in substitute command: '%c'",
+                fprintf(thread_stderr, "sed: %lu: %s: bad flag in substitute command: '%c'\n",
+			// errx(1, "%lu: %s: bad flag in substitute command: '%c'",
 					linenum, fname, *p);
+                pthread_exit(NULL);
 			break;
 		}
 		p++;
@@ -643,34 +718,46 @@
 	mbstate_t mbs1, mbs2;
 
 	if ((*py = y = malloc(sizeof(*y))) == NULL)
-		err(1, NULL);
+    { fprintf(thread_stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	y->multis = NULL;
 	y->nmultis = 0;
 
 	if (*p == '\0' || *p == '\\')
-		errx(1,
-	"%lu: %s: transform pattern can not be delimited by newline or backslash",
+    { fprintf(thread_stderr,
+             // errx(1,
+              "sed: %lu: %s: transform pattern can not be delimited by newline or backslash\n",
 			linenum, fname);
+        pthread_exit(NULL);
+    }
 	p = compile_delimited(p, old, 1);
 	if (p == NULL)
-		errx(1, "%lu: %s: unterminated transform source string",
+    { fprintf(thread_stderr, "sed: %lu: %s: unterminated transform source string\n",
+		// errx(1, "%lu: %s: unterminated transform source string",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	p = compile_delimited(p - 1, new, 1);
 	if (p == NULL)
-		errx(1, "%lu: %s: unterminated transform target string",
+    { fprintf(thread_stderr, "sed: %lu: %s: unterminated transform target string\n",
+		// errx(1, "%lu: %s: unterminated transform target string",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	EATSPACE();
 	op = old;
 	oldlen = mbsrtowcs(NULL, &op, 0, NULL);
 	if (oldlen == (size_t)-1)
-		err(1, NULL);
+    { fprintf(thread_stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	np = new;
 	newlen = mbsrtowcs(NULL, &np, 0, NULL);
 	if (newlen == (size_t)-1)
-		err(1, NULL);
+    { fprintf(thread_stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	if (newlen != oldlen)
-		errx(1, "%lu: %s: transform strings are not the same length",
+    { fprintf(thread_stderr, "sed: %lu: %s: transform strings are not the same length\n",
+		// errx(1, "%lu: %s: transform strings are not the same length",
 				linenum, fname);
+        pthread_exit(NULL);
+    }
 	if (MB_CUR_MAX == 1) {
 		/*
 		 * The single-byte encoding case is easy: generate a
@@ -706,7 +793,7 @@
 				y->multis = realloc(y->multis,
 				    (y->nmultis + 1) * sizeof(*y->multis));
 				if (y->multis == NULL)
-					err(1, NULL);
+                { fprintf(thread_stderr, "sed: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 				i = y->nmultis++;
 				y->multis[i].fromlen = oclen;
 				memcpy(y->multis[i].from, op, oclen);
@@ -732,7 +819,7 @@
 
 	asize = 2 * _POSIX2_LINE_MAX + 1;
 	if ((text = malloc(asize)) == NULL)
-		err(1, "malloc");
+    { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	size = 0;
 	while (cu_fgets(lbuf, sizeof(lbuf), NULL)) {
 		op = s = text + size;
@@ -751,12 +838,12 @@
 		if (asize - size < _POSIX2_LINE_MAX + 1) {
 			asize *= 2;
 			if ((text = realloc(text, asize)) == NULL)
-				err(1, "realloc");
+            { fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 		}
 	}
 	text[size] = '\0';
 	if ((p = realloc(text, size + 1)) == NULL)
-		err(1, "realloc");
+    { fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	return (p);
 }
 
@@ -776,7 +863,10 @@
 	case '/':				/* Context address */
 		p = compile_re(p, &a->u.r);
 		if (p == NULL)
-			errx(1, "%lu: %s: unterminated regular expression", linenum, fname);
+        { fprintf(thread_stderr, "sed: %lu: %s: unterminated regular expression\n", linenum, fname);
+            pthread_exit(NULL);
+         //   errx(1, "%lu: %s: unterminated regular expression", linenum, fname);
+        }
 		a->type = AT_RE;
 		return (p);
 
@@ -790,7 +880,9 @@
 		a->u.l = strtol(p, &end, 10);
 		return (end);
 	default:
-		errx(1, "%lu: %s: expected context address", linenum, fname);
+            fprintf(thread_stderr, "sed: %lu: %s: expected context address\n", linenum, fname);
+            pthread_exit(NULL);
+		// errx(1, "%lu: %s: expected context address", linenum, fname);
 		return (NULL);
 	}
 }
@@ -811,10 +903,11 @@
 		ws = isspace((unsigned char)*s);
 	*s = '\0';
 	if (ws)
-		warnx("%lu: %s: whitespace after %s", linenum, fname, ctype);
+        fprintf(thread_stderr, "sed: %lu: %s: whitespace after %s\n", linenum, fname, ctype);
+		// warnx("%lu: %s: whitespace after %s", linenum, fname, ctype);
 	len = s - start + 1;
 	if ((p = malloc(len)) == NULL)
-		err(1, "malloc");
+    { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	return (memmove(p, start, len));
 }
 
@@ -843,7 +936,10 @@
 				break;
 			}
 			if ((cp->u.c = findlabel(cp->t)) == NULL)
-				errx(1, "%lu: %s: undefined label '%s'", linenum, fname, cp->t);
+            { fprintf(thread_stderr, "sed: %lu: %s: undefined label '%s'\n", linenum, fname, cp->t);
+                pthread_exit(NULL);
+                // errx(1, "%lu: %s: undefined label '%s'", linenum, fname, cp->t);
+            }
 			free(cp->t);
 			break;
 		case '{':
@@ -868,9 +964,12 @@
 	lhp = &labels[h & LHMASK];
 	for (lh = *lhp; lh != NULL; lh = lh->lh_next)
 		if (lh->lh_hash == h && strcmp(cp->t, lh->lh_cmd->t) == 0)
-			errx(1, "%lu: %s: duplicate label '%s'", linenum, fname, cp->t);
+        { fprintf(thread_stderr, "sed: %lu: %s: duplicate label '%s'\n", linenum, fname, cp->t);
+            pthread_exit(NULL);
+    // errx(1, "%lu: %s: duplicate label '%s'", linenum, fname, cp->t);
+        }
 	if ((lh = malloc(sizeof *lh)) == NULL)
-		err(1, "malloc");
+    { fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, "malloc");
 	lh->lh_next = *lhp;
 	lh->lh_hash = h;
 	lh->lh_cmd = cp;
@@ -925,8 +1024,8 @@
 				continue;
 			}
 			if (!lh->lh_ref)
-				warnx("%lu: %s: unused label '%s'",
-				    linenum, fname, lh->lh_cmd->t);
+                fprintf(thread_stderr, "sed: %lu: %s: unused label '%s'\n", linenum, fname, lh->lh_cmd->t);
+            // warnx("%lu: %s: unused label '%s'", linenum, fname, lh->lh_cmd->t);
 			free(lh);
 		}
 	}
diff -Naur text_cmds-99/sed/extern.h text_cmds/sed/extern.h
--- text_cmds-99/sed/extern.h	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/extern.h	2018-01-23 22:30:24.000000000 +0100
@@ -34,16 +34,16 @@
  * $FreeBSD: src/usr.bin/sed/extern.h,v 1.13 2004/08/09 15:29:41 dds Exp $
  */
 
-extern struct s_command *prog;
-extern struct s_appends *appends;
-extern regmatch_t *match;
-extern size_t maxnsub;
-extern u_long linenum;
-extern int appendnum;
-extern int aflag, eflag, nflag;
-extern const char *fname, *outfname;
-extern FILE *infile, *outfile;
-extern int rflags;	/* regex flags to use */
+extern __thread struct s_command *prog;
+extern __thread struct s_appends *appends;
+extern __thread regmatch_t *match;
+extern __thread size_t maxnsub;
+extern __thread u_long linenum;
+extern __thread int appendnum;
+extern __thread int aflag, eflag, sed_nflag;
+extern __thread const char *fname, *outfname;
+extern __thread FILE *infile, *outfile;
+extern __thread int rflags;	/* regex flags to use */
 
 void	 cfclose(struct s_command *, struct s_command *);
 void	 compile(void);
diff -Naur text_cmds-99/sed/main.c text_cmds/sed/main.c
--- text_cmds-99/sed/main.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/main.c	2018-01-23 22:30:24.000000000 +0100
@@ -64,6 +64,9 @@
 
 #include "defs.h"
 #include "extern.h"
+// iOS changes:
+#include "ios_error.h"
+#include <pthread.h>
 
 /*
  * Linked list of units (strings and files) to be compiled
@@ -92,25 +95,25 @@
  * Linked list pointer to files and pointer to current
  * next pointer.
  */
-static struct s_flist *files, **fl_nextp = &files;
+static struct s_flist *files = NULL, **fl_nextp = &files;
 
-FILE *infile;			/* Current input file */
-FILE *outfile;			/* Current output file */
+__thread FILE *infile;			/* Current input file */
+__thread FILE *outfile;			/* Current output file */
 
-int aflag, eflag, nflag;
-int rflags = 0;
+__thread int aflag, eflag, sed_nflag;
+__thread int rflags = 0;
 static int rval;		/* Exit status */
 
 /*
  * Current file and line number; line numbers restart across compilation
  * units, but span across input files.
  */
-const char *fname;		/* File name. */
-const char *outfname;		/* Output file name */
+const __thread char *fname;		/* File name. */
+const __thread char *outfname;		/* Output file name */
 static char oldfname[PATH_MAX];	/* Old file name (for in-place editing) */
 static char tmpfname[PATH_MAX];	/* Temporary file name (for in-place editing) */
-const char *inplace;		/* Inplace edit file extension. */
-u_long linenum;
+const __thread char *inplace;		/* Inplace edit file extension. */
+__thread u_long linenum;
 
 static void add_compunit(enum e_cut, char *);
 static void add_file(char *);
@@ -118,11 +121,25 @@
 static void usage(void);
 
 int
-main(int argc, char *argv[])
+sed_main(int argc, char *argv[])
 {
 	int c, fflag;
 	char *temp_arg;
 
+    // init all flags:
+    aflag = eflag = sed_nflag = rflags = 0;
+    infile = NULL;
+    outfile = NULL;
+    fl_nextp = &files;
+    if (files != NULL) {
+        while (files != NULL) { struct s_flist *next = files->next; free(files); files = next; }
+    }
+    cu_nextp = &script;
+    if (script != NULL) {
+        while (script != NULL) { struct s_compunit *next = script->next; free(script); script = next; }
+    }
+    rval = 0;        /* Exit status */
+
 	(void) setlocale(LC_ALL, "");
 
 	fflag = 0;
@@ -139,7 +156,7 @@
 		case 'e':
 			eflag = 1;
 			if ((temp_arg = malloc(strlen(optarg) + 2)) == NULL)
-				err(1, "malloc");
+                fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 			strcpy(temp_arg, optarg);
 			strcat(temp_arg, "\n");
 			add_compunit(CU_STRING, temp_arg);
@@ -152,11 +169,11 @@
 			inplace = optarg;
 			break;
 		case 'l':
-			if(setlinebuf(stdout) != 0)
-				warnx("setlinebuf() failed");
+			if(setlinebuf(thread_stdout) != 0)
+                fprintf(thread_stderr, "sed: setlinebuf() failed\n"); // warnx("setlinebuf() failed");
 			break;
 		case 'n':
-			nflag = 1;
+			sed_nflag = 1;
 			break;
 		default:
 		case '?':
@@ -181,18 +198,22 @@
 		add_file(NULL);
 	process();
 	cfclose(prog, NULL);
-	if (fclose(stdout))
-		err(1, "stdout");
-	exit(rval);
+	// if (fclose(stdout))
+	//	err(1, "stdout");
+	// exit(rval);
+    if ((infile != NULL) && (infile != thread_stdin)) fclose(infile);
+    if ((outfile != NULL) && (outfile != thread_stdout)) fclose(outfile);
+    return 0;
 }
 
 static void
 usage(void)
 {
-	(void)fprintf(stderr, "%s\n%s\n",
+	(void)fprintf(thread_stderr, "%s\n%s\n",
 		"usage: sed script [-Ealn] [-i extension] [file ...]",
 		"       sed [-Ealn] [-i extension] [-e script] ... [-f script_file] ... [file ...]");
-	exit(1);
+    pthread_exit(NULL);
+	// exit(1);
 }
 
 /*
@@ -220,7 +241,7 @@
 		switch (script->type) {
 		case CU_FILE:
 			if ((f = fopen(script->s, "r")) == NULL)
-				err(1, "%s", script->s);
+                fprintf(thread_stderr, "sed: %s: %s\n", script->s, strerror(errno)); // err(1, "%s", script->s);
 			fname = script->s;
 			state = ST_FILE;
 			goto again;
@@ -239,7 +260,7 @@
 		if ((p = fgets(buf, n, f)) != NULL) {
 			linenum++;
 			if (linenum == 1 && buf[0] == '#' && buf[1] == 'n')
-				nflag = 1;
+				sed_nflag = 1;
 			if (more != NULL)
 				*more = !feof(f);
 			return (p);
@@ -250,7 +271,7 @@
 		goto again;
 	case ST_STRING:
 		if (linenum == 0 && s[0] == '#' && s[1] == 'n')
-			nflag = 1;
+			sed_nflag = 1;
 		p = buf;
 		for (;;) {
 			if (n-- <= 1) {
@@ -308,10 +329,10 @@
 		/* stdin? */
 		if (files->fname == NULL) {
 			if (inplace != NULL)
-				errx(1, "-i may not be used with stdin");
-			infile = stdin;
+                fprintf(thread_stderr, "sed: -i may not be used with stdin\n"); //errx(1, "-i may not be used with stdin");
+			infile = thread_stdin;
 			fname = "stdin";
-			outfile = stdout;
+			outfile = thread_stdout;
 			outfname = "stdout";
 		}
 		firstfile = 1;
@@ -323,22 +344,23 @@
 			break;
 		}
 		/* If we are here then either eof or no files are open yet */
-		if (infile == stdin) {
+		if (infile == thread_stdin) {
 			sp->len = 0;
 			return (0);
 		}
 		if (infile != NULL) {
-			fclose(infile);
+			if (infile != thread_stdin) fclose(infile);
 			if (*oldfname != '\0') {
 				if (rename(fname, oldfname) != 0) {
-					warn("rename()");
+                    fprintf(thread_stderr, "sed: rename(): %s\n", strerror(errno)); // warn("rename()");
 					unlink(tmpfname);
-					exit(1);
+                    pthread_exit(NULL);
+					// exit(1);
 				}
 				*oldfname = '\0';
 			}
 			if (*tmpfname != '\0') {
-				if (outfile != NULL && outfile != stdout)
+				if (outfile != NULL && outfile != thread_stdout)
 					fclose(outfile);
 				outfile = NULL;
 				rename(tmpfname, fname);
@@ -357,36 +379,41 @@
 		fname = files->fname;
 		if (inplace != NULL) {
 			if (lstat(fname, &sb) != 0)
-				err(1, "%s", fname);
+                fprintf(thread_stderr, "sed: %s: %s\n", fname, strerror(errno)); // err(1, "%s", fname);
 			if (!(sb.st_mode & S_IFREG))
-				errx(1, "%s: %s %s", fname,
-				    "in-place editing only",
-				    "works for regular files");
+                fprintf(thread_stderr, "sed: %s: %s %s\n", fname,
+                     "in-place editing only",
+                     "works for regular files");
+				//errx(1, "%s: %s %s", fname,
+				//    "in-place editing only",
+				//    "works for regular files");
 			if (*inplace != '\0') {
 				strlcpy(oldfname, fname,
 				    sizeof(oldfname));
 				len = strlcat(oldfname, inplace,
 				    sizeof(oldfname));
 				if (len > sizeof(oldfname))
-					errx(1, "%s: name too long", fname);
+                    fprintf(thread_stderr, "sed: %s: name too long\n", fname);
+                // errx(1, "%s: name too long", fname);
 			}
 			len = snprintf(tmpfname, sizeof(tmpfname),
 			    "%s/.!%ld!%s", dirname(fname), (long)getpid(),
 			    basename(fname));
 			if (len >= sizeof(tmpfname))
-				errx(1, "%s: name too long", fname);
+                fprintf(thread_stderr, "sed: %s: name too long\n", fname);
+				// errx(1, "%s: name too long", fname);
 			unlink(tmpfname);
 			if ((outfile = fopen(tmpfname, "w")) == NULL)
-				err(1, "%s", fname);
+                fprintf(thread_stderr, "sed: %s: %s\n", fname, strerror(errno)); // err(1, "%s", fname);
 			fchown(fileno(outfile), sb.st_uid, sb.st_gid);
 			fchmod(fileno(outfile), sb.st_mode & ALLPERMS);
 			outfname = tmpfname;
 		} else {
-			outfile = stdout;
+			outfile = thread_stdout;
 			outfname = "stdout";
 		}
 		if ((infile = fopen(fname, "r")) == NULL) {
-			warn("%s", fname);
+            fprintf(thread_stderr, "sed: %s: %s\n", fname, strerror(errno)); // warn("%s", fname);
 			rval = 1;
 			continue;
 		}
@@ -401,7 +428,8 @@
 	 */
 	p = fgetln(infile, &len);
 	if (ferror(infile))
-		errx(1, "%s: %s", fname, strerror(errno ? errno : EIO));
+        fprintf(thread_stderr, "sed: %s: %s\n", fname, strerror(errno ? errno : EIO));
+        // errx(1, "%s: %s", fname, strerror(errno ? errno : EIO));
 	if (len != 0 && p[len - 1] == '\n')
 		len--;
 	cspace(sp, p, len, spflag);
@@ -420,7 +448,7 @@
 	struct s_compunit *cu;
 
 	if ((cu = malloc(sizeof(struct s_compunit))) == NULL)
-		err(1, "malloc");
+        fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 	cu->type = type;
 	cu->s = s;
 	cu->next = NULL;
@@ -437,8 +465,9 @@
 	struct s_flist *fp;
 
 	if ((fp = malloc(sizeof(struct s_flist))) == NULL)
-		err(1, "malloc");
+        fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 	fp->next = NULL;
+    // That's the stuff:
 	*fl_nextp = fp;
 	fp->fname = s;
 	fl_nextp = &fp->next;
diff -Naur text_cmds-99/sed/misc.c text_cmds/sed/misc.c
--- text_cmds-99/sed/misc.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/misc.c	2018-01-23 22:30:24.000000000 +0100
@@ -49,6 +49,9 @@
 
 #include "defs.h"
 #include "extern.h"
+// iOS
+#include <errno.h>
+#include "ios_error.h"
 
 /*
  * Return a string for a regular expression error passed.  This is overkill,
@@ -65,7 +68,7 @@
 		free(oe);
 	s = regerror(errcode, preg, NULL, 0);
 	if ((oe = malloc(s)) == NULL)
-		err(1, "malloc");
+        fprintf(thread_stderr, "sed: malloc: %s\n", strerror(errno)); // err(1, "malloc");
 	(void)regerror(errcode, preg, oe, s);
 	return (oe);
 }
diff -Naur text_cmds-99/sed/process.c text_cmds/sed/process.c
--- text_cmds-99/sed/process.c	2005-09-20 23:36:44.000000000 +0200
+++ text_cmds/sed/process.c	2018-01-23 22:30:24.000000000 +0100
@@ -58,6 +58,7 @@
 
 #include "defs.h"
 #include "extern.h"
+#include "ios_error.h"
 
 static SPACE HS, PS, SS, YS;
 #define	pd		PS.deleted
@@ -74,16 +75,16 @@
 static void		 regsub(SPACE *, char *, char *);
 static int		 substitute(struct s_command *);
 
-struct s_appends *appends;	/* Array of pointers to strings to append. */
+__thread struct s_appends *appends;	/* Array of pointers to strings to append. */
 static int appendx;		/* Index into appends array. */
-int appendnum;			/* Size of appends array. */
+__thread int appendnum;			/* Size of appends array. */
 
 static int lastaddr;		/* Set by applies if last address of a range. */
 static int sdone;		/* If any substitutes since last line input. */
 				/* Iov structure for 'w' commands. */
 static regex_t *defpreg;
-size_t maxnsub;
-regmatch_t *match;
+__thread size_t maxnsub;
+__thread regmatch_t *match;
 
 #define OUT(s) { fwrite(s, sizeof(u_char), psl, outfile); fputc('\n', outfile); }
 
@@ -116,7 +117,7 @@
 					if ((appends = realloc(appends,
 					    sizeof(struct s_appends) *
 					    (appendnum *= 2))) == NULL)
-						err(1, "realloc");
+                        fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); // err(1, "realloc");
 				appends[appendx].type = AP_STRING;
 				appends[appendx].s = cp->t;
 				appends[appendx].len = strlen(cp->t);
@@ -167,7 +168,7 @@
 				lputs(ps, psl);
 				break;
 			case 'n':
-				if (!nflag && !pd)
+				if (!sed_nflag && !pd)
 					OUT(ps)
 				flush_appends();
 				if (!mf_fgets(&PS, REPLACE))
@@ -198,17 +199,17 @@
 					psl = oldpsl;
 				break;
 			case 'q':
-				if (!nflag && !pd)
+				if (!sed_nflag && !pd)
 					OUT(ps)
 				flush_appends();
-				lseek(STDIN_FILENO, ftell(stdin), SEEK_SET);
+				lseek(fileno(thread_stdin), ftell(thread_stdin), SEEK_SET);
 				exit(0);
 			case 'r':
 				if (appendx >= appendnum)
 					if ((appends = realloc(appends,
 					    sizeof(struct s_appends) *
 					    (appendnum *= 2))) == NULL)
-						err(1, "realloc");
+						        fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); // err(1, "realloc");
 				appends[appendx].type = AP_FILE;
 				appends[appendx].s = cp->t;
 				appends[appendx].len = strlen(cp->t);
@@ -230,10 +231,10 @@
 				if (cp->u.fd == -1 && (cp->u.fd = open(cp->t,
 				    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC,
 				    DEFFILEMODE)) == -1)
-					err(1, "%s", cp->t);
+                    fprintf(thread_stderr, "sed: %s: %s\n", cp->t, strerror(errno)); // err(1, "%s", cp->t);
 				if (write(cp->u.fd, ps, psl) != psl ||
 				    write(cp->u.fd, "\n", 1) != 1)
-					err(1, "%s", cp->t);
+                    fprintf(thread_stderr, "sed: %s: %s\n", cp->t, strerror(errno)); // err(1, "%s", cp->t);
 				break;
 			case 'x':
 				if (hs == NULL)
@@ -256,7 +257,7 @@
 			cp = cp->next;
 		} /* for all cp */
 
-new:		if (!nflag && !pd)
+new:		if (!sed_nflag && !pd)
 			OUT(ps)
 		flush_appends();
 	} /* for all lines */
@@ -329,8 +330,10 @@
 	if (re == NULL) {
 		if (defpreg != NULL && cp->u.s->maxbref > defpreg->re_nsub) {
 			linenum = cp->u.s->linenum;
-			errx(1, "%lu: %s: \\%d not defined in the RE",
+            fprintf(thread_stderr, "sed: %lu: %s: \\%d not defined in the RE\n",
+			// errx(1, "%lu: %s: \\%d not defined in the RE",
 					linenum, fname, cp->u.s->maxbref);
+            pthread_exit(NULL);
 		}
 	}
 	if (!regexec_e(re, s, 0, 0, psl))
@@ -414,10 +417,10 @@
 	if (cp->u.s->wfile && !pd) {
 		if (cp->u.s->wfd == -1 && (cp->u.s->wfd = open(cp->u.s->wfile,
 		    O_WRONLY|O_APPEND|O_CREAT|O_TRUNC, DEFFILEMODE)) == -1)
-			err(1, "%s", cp->u.s->wfile);
+            fprintf(thread_stderr, "sed: %s: %s\n", cp->u.s->wfile, strerror(errno)); // err(1, "%s", cp->u.s->wfile);
 		if (write(cp->u.s->wfd, ps, psl) != psl ||
 		    write(cp->u.s->wfd, "\n", 1) != 1)
-			err(1, "%s", cp->u.s->wfile);
+            fprintf(thread_stderr, "sed: %s: %s\n", cp->u.s->wfile, strerror(errno)); // err(1, "%s", cp->u.s->wfile);
 	}
 	return (1);
 }
@@ -511,7 +514,10 @@
 			break;
 		}
 	if (ferror(outfile))
-		errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+    { fprintf(thread_stderr, "sed: %s: %s\n", outfname, strerror(errno ? errno : EIO));
+        pthread_exit(NULL);
+    // errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+    }
 	appendx = sdone = 0;
 }
 
@@ -527,12 +533,12 @@
 	wchar_t wc;
 	mbstate_t mbs;
 
-	if (outfile != stdout)
+	if (outfile != thread_stdout)
 		termwidth = 60;
 	if (termwidth == -1) {
 		if ((p = getenv("COLUMNS")) && *p != '\0')
 			termwidth = atoi(p);
-		else if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
+		else if (ioctl(fileno(thread_stdout), TIOCGWINSZ, &win) == 0 &&
 		    win.ws_col > 0)
 			termwidth = win.ws_col;
 		else
@@ -589,8 +595,11 @@
 		fprintf(outfile, "\\\n");
 	(void)fputc('$', outfile);
 	(void)fputc('\n', outfile);
-	if (ferror(outfile))
-		errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+    if (ferror(outfile)) {
+        fprintf(thread_stderr, "sed: %s: %s\n", outfname, strerror(errno ? errno : EIO));
+        // errx(1, "%s: %s", outfname, strerror(errno ? errno : EIO));
+        pthread_exit(NULL);
+    }
 }
 
 static __inline int
@@ -601,7 +610,10 @@
 
 	if (preg == NULL) {
 		if (defpreg == NULL)
-			errx(1, "first RE may not be empty");
+        { fprintf(thread_stderr, "sed: first RE may not be empty\n");
+            // errx(1, "first RE may not be empty");
+            pthread_exit(NULL);
+        }
 	} else
 		defpreg = preg;
 
@@ -617,7 +629,9 @@
 	case REG_NOMATCH:
 		return (0);
 	}
-	errx(1, "RE error: %s", strregerror(eval, defpreg));
+    fprintf(thread_stderr, "sed: RE error: %s\n", strregerror(eval, defpreg));
+    pthread_exit(NULL);
+    // errx(1, "RE error: %s", strregerror(eval, defpreg));
 	/* NOTREACHED */
 }
 
@@ -637,9 +651,10 @@
 		sp->blen += (reqlen) + 1024;				\
 		if ((sp->space = sp->back = realloc(sp->back, sp->blen)) \
 		    == NULL)						\
-			err(1, "realloc");				\
+            fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); \
 		dst = sp->space + sp->len;				\
 	}
+    // err(1, "realloc");
 
 	dst = sp->space + sp->len;
 	while ((c = *src++) != '\0') {
@@ -683,7 +698,7 @@
 		sp->blen = tlen + 1024;
 		if ((sp->space = sp->back = realloc(sp->back, sp->blen)) ==
 		    NULL)
-			err(1, "realloc");
+			        fprintf(thread_stderr, "sed: realloc: %s\n", strerror(errno)); // err(1, "realloc");
 	}
 
 	if (spflag == REPLACE)
@@ -705,12 +720,12 @@
 		switch(cp->code) {
 		case 's':
 			if (cp->u.s->wfd != -1 && close(cp->u.s->wfd))
-				err(1, "%s", cp->u.s->wfile);
+                fprintf(thread_stderr, "sed: %s: %s\n", cp->u.s->wfile, strerror(errno)); // err(1, "%s", cp->u.s->wfile);
 			cp->u.s->wfd = -1;
 			break;
 		case 'w':
 			if (cp->u.fd != -1 && close(cp->u.fd))
-				err(1, "%s", cp->t);
+                fprintf(thread_stderr, "sed: %s: %s\n", cp->t, strerror(errno)); // err(1, "%s", cp->t);
 			cp->u.fd = -1;
 			break;
 		case '{':
diff -Naur text_cmds-99/tr/str.c text_cmds/tr/str.c
--- text_cmds-99/tr/str.c	2005-08-18 23:20:18.000000000 +0200
+++ text_cmds/tr/str.c	2018-01-23 22:30:24.000000000 +0100
@@ -53,6 +53,10 @@
 #include <wctype.h>
 
 #include "extern.h"
+// iOS changes:
+#include "ios_error.h"
+#include <pthread.h>
+
 
 static int      backslash(STR *, int *);
 static int	bracket(STR *);
@@ -193,8 +197,10 @@
 	STR *s;
 {
 
-	if ((s->cclass = wctype(s->str)) == 0)
-		errx(1, "unknown class %s", s->str);
+    if ((s->cclass = wctype(s->str)) == 0) {
+		fprintf(thread_stderr, "tr: unknown class %s\n", s->str); // errx
+        pthread_exit(NULL);
+    }
 	s->cnt = 0;
 	s->lastch = -1;		/* incremented before check in next() */
 	if (strcmp(s->str, "upper") == 0)
@@ -216,17 +222,21 @@
 
 	if (*s->str == '\\') {
 		s->equiv[0] = backslash(s, NULL);
-		if (*s->str != '=')
-			errx(1, "misplaced equivalence equals sign");
+        if (*s->str != '=') {
+			fprintf(thread_stderr, "tr: misplaced equivalence equals sign\n"); // errx
+            pthread_exit(NULL);
+        }
 		s->str += 2;
 	} else {
 		clen = mbrtowc(&wc, s->str, MB_LEN_MAX, NULL);
 		if (clen == (size_t)-1 || clen == (size_t)-2 || clen == 0)
 			errc(1, EILSEQ, NULL);
 		s->equiv[0] = wc;
-		if (s->str[clen] != '=')
-			errx(1, "misplaced equivalence equals sign");
-		s->str += clen + 2;
+        if (s->str[clen] != '=') {
+			fprintf(thread_stderr, "tr: misplaced equivalence equals sign\n"); // errx
+            pthread_exit(NULL);
+        }
+        s->str += clen + 2;
 	}
 
 	/*
@@ -294,8 +304,11 @@
 		s->str = savestart;
 		return (0);
 	}
-	if ((s->set = p = malloc((NCHARS_SB + 1) * sizeof(int))) == NULL)
-		err(1, "genrange() malloc");
+    if ((s->set = p = malloc((NCHARS_SB + 1) * sizeof(int))) == NULL) {
+		// err(1, "genrange() malloc");
+        fprintf(thread_stderr, "tr: genrange() malloc: %s", strerror(errno));
+        pthread_exit(NULL);
+    }
 	for (cnt = 0; cnt < NCHARS_SB; cnt++)
 		if (charcoll((const void *)&cnt, (const void *)&(s->lastch)) >= 0 &&
 		    charcoll((const void *)&cnt, (const void *)&stopval) <= 0)
@@ -319,8 +332,11 @@
 	size_t clen;
 
 #ifndef __APPLE__
-	if (s->which == STRING1)
-		errx(1, "sequences only valid in string2");
+    if (s->which == STRING1) {
+		fprintf(thread_stderr, "tr: sequences only valid in string2\n"); // errx
+        pthread_exit(NULL);
+    }
+        
 #endif /* !__APPLE__ */
 
 	if (*s->str == '\\')
@@ -332,8 +348,10 @@
 		s->lastch = wc;
 		s->str += clen;
 	}
-	if (*s->str != '*')
-		errx(1, "misplaced sequence asterisk");
+    if (*s->str != '*') {
+		fprintf(thread_stderr, "tr: misplaced sequence asterisk\n"); // errx
+        pthread_exit(NULL);
+    }
 
 	switch (*++s->str) {
 	case '\\':
@@ -351,7 +369,8 @@
 				break;
 			}
 		}
-		errx(1, "illegal sequence count");
+		fprintf(thread_stderr, "tr: illegal sequence count\n"); // errx
+        pthread_exit(NULL);
 		/* NOTREACHED */
 	}
 
diff -Naur text_cmds-99/tr/tr.c text_cmds/tr/tr.c
--- text_cmds-99/tr/tr.c	2006-04-21 01:51:01.000000000 +0200
+++ text_cmds/tr/tr.c	2018-01-23 22:30:24.000000000 +0100
@@ -61,6 +61,9 @@
 #include "cmap.h"
 #include "cset.h"
 #include "extern.h"
+// iOS changes:
+#include "ios_error.h"
+#include <errno.h>
 
 STR s1 = { STRING1, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
 STR s2 = { STRING2, NORMAL, 0, OOBCH, 0, { 0, OOBCH }, NULL, NULL };
@@ -68,15 +71,71 @@
 static struct cset *setup(char *, STR *, int, int);
 static void usage(void);
 
+static void initSTR(STR* s) {
+    s->which = STRING1;
+    s->state = NORMAL;
+    s->cnt = 0;
+    s->lastch = OOBCH;
+    s->cclass = 0;
+    s->equiv[0] = 0;
+    s->equiv[1] = OOBCH;
+    if (s->set != NULL) { free(s->set); s->set = NULL; }
+    s->str = NULL;
+}
+
+static void csnode_free(struct csnode *c) {
+    if (c == NULL) return;
+    
+    struct csnode* left = c->csn_left;
+    struct csnode* right = c->csn_right;
+    free(c); c = NULL;
+    csnode_free(left); left = NULL;
+    csnode_free(right); right = NULL;
+}
+
+static void cset_free(struct cset *t)
+{
+    if (t == NULL) return;
+    struct csclass* class = t->cs_classes;
+    while (class) { struct csclass* n = class->csc_next; free(class); class = n; }
+    t->cs_classes = NULL;
+    
+    struct csnode* root = t->cs_root;
+    csnode_free(root);
+    t->cs_root = NULL;
+}
+
+static void cmapnode_free(struct cmapnode *c) {
+    if (c == NULL) return;
+    
+    struct cmapnode* left = c->cmn_left;
+    struct cmapnode* right = c->cmn_right;
+    free(c); c = NULL;
+    cmapnode_free(left); left = NULL;
+    cmapnode_free(right); right = NULL;
+}
+
+static void cmap_free(struct cmap *m)
+{
+    if (m == NULL) return;
+    cmapnode_free(m->cm_root);
+    free(m);
+    m = NULL;
+}
+
+
 int
-main(int argc, char **argv)
+tr_main(int argc, char **argv)
 {
 	static int carray[NCHARS_SB];
 	struct cmap *map;
-	struct cset *delete, *squeeze;
+	struct cset *delete , *squeeze;
 	int n, *p;
 	int Cflag, cflag, dflag, sflag, isstring2;
 	wint_t ch, cnt, lastch;
+    
+    // iOS: reinitialize parameters:
+    initSTR(&s1); initSTR(&s2); s2.which = STRING2;
 
 	(void)setlocale(LC_ALL, "");
 
@@ -98,7 +157,7 @@
 			sflag = 1;
 			break;
 		case 'u':
-			setbuf(stdout, (char *)NULL);
+			setbuf(thread_stdout, (char *)NULL);
 			break;
 		case '?':
 		default:
@@ -138,11 +197,13 @@
 			if (!cset_in(delete, ch) &&
 			    (lastch != ch || !cset_in(squeeze, ch))) {
 				lastch = ch;
-				(void)putwchar(ch);
+                (void)putwc(ch, thread_stdout); // (void)putwchar(ch);
 			}
-		if (ferror(stdin))
-			err(1, NULL);
-		exit(0);
+		if (ferror(thread_stdin))
+            fprintf(thread_stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+        cset_free(delete);
+        cset_free(squeeze);
+        pthread_exit(NULL); // exit(0);
 	}
 
 	/*
@@ -157,10 +218,11 @@
 
 		while ((ch = getwchar()) != WEOF)
 			if (!cset_in(delete, ch))
-				(void)putwchar(ch);
-		if (ferror(stdin))
-			err(1, NULL);
-		exit(0);
+				(void)putwc(ch, thread_stdout); // (void)putwchar(ch);
+		if (ferror(thread_stdin))
+            fprintf(thread_stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+        cset_free(delete);
+		pthread_exit(NULL); // exit(0);
 	}
 
 	/*
@@ -173,11 +235,12 @@
 		for (lastch = OOBCH; (ch = getwchar()) != WEOF;)
 			if (lastch != ch || !cset_in(squeeze, ch)) {
 				lastch = ch;
-				(void)putwchar(ch);
+				(void)putwc(ch, thread_stdout); // (void)putwchar(ch);
 			}
-		if (ferror(stdin))
-			err(1, NULL);
-		exit(0);
+		if (ferror(thread_stdin))
+			fprintf(thread_stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+        cset_free(squeeze);
+		pthread_exit(NULL); // exit(0);
 	}
 
 	/*
@@ -191,22 +254,30 @@
 
 	map = cmap_alloc();
 	if (map == NULL)
-		err(1, NULL);
+    { fprintf(thread_stderr, "tr: %s\n", strerror(errno)); pthread_exit(NULL); }// err(1, NULL);
 	squeeze = cset_alloc();
 	if (squeeze == NULL)
-		err(1, NULL);
+    { fprintf(thread_stderr, "tr: %s\n", strerror(errno)); cmap_free(map); pthread_exit(NULL); } // err(1, NULL);
 
 	s1.str = argv[0];
 
 	if (Cflag || cflag) {
 		cmap_default(map, OOBCH);
-		if ((s2.str = strdup(argv[1])) == NULL)
-			errx(1, "strdup(argv[1])");
+        if ((s2.str = strdup(argv[1])) == NULL) { // potential memory leak
+			fprintf(thread_stderr, "tr: %s\n", "strdup(argv[1])"); // errx
+            cset_free(squeeze);
+            cmap_free(map);
+            pthread_exit(NULL);
+        }
 	} else
 		s2.str = argv[1];
 
-	if (!next(&s2))
-		errx(1, "empty string2");
+    if (!next(&s2)) {
+        fprintf(thread_stderr, "tr: %s\n", "empty string2"); // errx
+        cset_free(squeeze);
+        cmap_free(map);
+        pthread_exit(NULL);
+    }
 
 	/*
 	 * For -s result will contain only those characters defined
@@ -323,18 +394,21 @@
 				ch = cmap_lookup(map, ch);
 			if (lastch != ch || !cset_in(squeeze, ch)) {
 				lastch = ch;
-				(void)putwchar(ch);
+				(void)putwc(ch, thread_stdout); // (void)putwchar(ch);
 			}
 		}
 	else
 		while ((ch = getwchar()) != WEOF) {
 			if (!Cflag || iswrune(ch))
 				ch = cmap_lookup(map, ch);
-			(void)putwchar(ch);
+			(void)putwc(ch, thread_stdout); // (void)putwchar(ch);
 		}
-	if (ferror(stdin))
-		err(1, NULL);
-	exit (0);
+	if (ferror(thread_stdin))
+		fprintf(thread_stderr, "tr: %s\n", strerror(errno)); // err(1, NULL);
+    cset_free(squeeze);
+    cmap_free(map);
+    pthread_exit(NULL);
+	// exit (0);
 }
 
 static struct cset *
@@ -344,7 +418,7 @@
 
 	cs = cset_alloc();
 	if (cs == NULL)
-		err(1, NULL);
+    { fprintf(thread_stderr, "tr: %s\n", strerror(errno)); pthread_exit(NULL); } // err(1, NULL);
 	str->str = arg;
 	while (next(str))
 		cset_add(cs, str->lastch);
@@ -369,10 +443,10 @@
 static void
 usage(void)
 {
-	(void)fprintf(stderr, "%s\n%s\n%s\n%s\n",
+	(void)fprintf(thread_stderr, "%s\n%s\n%s\n%s\n",
 		"usage: tr [-Ccsu] string1 string2",
 		"       tr [-Ccu] -d string1",
 		"       tr [-Ccu] -s string1",
 		"       tr [-Ccu] -ds string1 string2");
-	exit(1);
+	pthread_exit(NULL); // exit(1);
 }
diff -Naur text_cmds-99/wc/wc.c text_cmds/wc/wc.c
--- text_cmds-99/wc/wc.c	2008-02-26 02:39:32.000000000 +0100
+++ text_cmds/wc/wc.c	2018-01-23 22:30:24.000000000 +0100
@@ -51,7 +51,7 @@
 #include <sys/stat.h>
 
 #include <ctype.h>
-#include <err.h>
+// #include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <locale.h>
@@ -62,24 +62,29 @@
 #include <unistd.h>
 #include <wchar.h>
 #include <wctype.h>
+#include "ios_error.h"
 
 /* We allocte this much memory statically, and use it as a fallback for
   malloc failure, or statfs failure.  So it should be small, but not
   "too small" */
 #define SMALL_BUF_SIZE (1024 * 8)
 
-uintmax_t tlinect, twordct, tcharct;
-int doline, doword, dochar, domulti;
+static uintmax_t tlinect, twordct, tcharct;
+static int doline, doword, dochar, domulti;
 
 static int	cnt(const char *);
 static void	usage(void);
 
 int
-main(int argc, char *argv[])
+wc_main(int argc, char *argv[])
 {
 	int ch, errors, total;
 
 	(void) setlocale(LC_CTYPE, "");
+    // Initialize flags:
+    doline = doword = dochar =  domulti = 0;
+    tlinect = twordct = tcharct = 0;
+    optind = 1; opterr = 1; optreset = 1;
 
 	while ((ch = getopt(argc, argv, "clmw")) != -1)
 		switch((char)ch) {
@@ -114,25 +119,26 @@
 		if (cnt((char *)NULL) != 0)
 			++errors;
 		else
-			(void)printf("\n");
+			(void)fprintf(thread_stdout, "\n");
 	}
 	else do {
 		if (cnt(*argv) != 0)
 			++errors;
 		else
-			(void)printf(" %s\n", *argv);
+			(void)fprintf(thread_stdout, " %s\n", *argv);
 		++total;
 	} while(*++argv);
 
 	if (total > 1) {
 		if (doline)
-			(void)printf(" %7ju", tlinect);
+			(void)fprintf(thread_stdout, " %7ju", tlinect);
 		if (doword)
-			(void)printf(" %7ju", twordct);
+			(void)fprintf(thread_stdout, " %7ju", twordct);
 		if (dochar || domulti)
-			(void)printf(" %7ju", tcharct);
-		(void)printf(" total\n");
+			(void)fprintf(thread_stdout, " %7ju", tcharct);
+		(void)fprintf(thread_stdout, " total\n");
 	}
+    optarg = NULL; opterr = 0; optind = 0;
 	exit(errors == 0 ? 0 : 1);
 }
 
@@ -156,10 +162,11 @@
 	linect = wordct = charct = 0;
 	if (file == NULL) {
 		file = "stdin";
-		fd = STDIN_FILENO;
+		fd = fileno(thread_stdin);
 	} else {
 		if ((fd = open(file, O_RDONLY, 0)) < 0) {
-			warn("%s: open", file);
+            fprintf(thread_stderr, "wc: %s: open: %s\n", file, strerror(errno));
+			// warn("%s: open", file);
 			return (1);
 		}
 	}
@@ -187,22 +194,23 @@
 	 * logic.
 	 */
 	if (doline) {
-		while ((len = read(fd, buf, buf_size))) {
+        while ((len = read(fd, buf, buf_size))) {
 			if (len == -1) {
-				warn("%s: read", file);
+                fprintf(thread_stderr, "wc: %s: read: %s\n", file, strerror(errno));
+                // warn("%s: read", file);
 				(void)close(fd);
 				return (1);
 			}
 			charct += len;
 			for (p = buf; len--; ++p)
-				if (*p == '\n')
+                if (*p == '\n')
 					++linect;
 		}
 		tlinect += linect;
-		(void)printf(" %7ju", linect);
+		(void)fprintf(thread_stdout, " %7ju", linect);
 		if (dochar) {
 			tcharct += charct;
-			(void)printf(" %7ju", charct);
+			(void)fprintf(thread_stdout, " %7ju", charct);
 		}
 		(void)close(fd);
 		return (0);
@@ -213,12 +221,13 @@
 	 */
 	if (dochar || domulti) {
 		if (fstat(fd, &sb)) {
-			warn("%s: fstat", file);
+            fprintf(thread_stderr, "wc: %s: fstat: %s\n", file, strerror(errno));
+            // warn("%s: fstat", file);
 			(void)close(fd);
 			return (1);
 		}
 		if (S_ISREG(sb.st_mode)) {
-			(void)printf(" %7lld", (long long)sb.st_size);
+			(void)fprintf(thread_stdout, " %7lld", (long long)sb.st_size);
 			tcharct += sb.st_size;
 			(void)close(fd);
 			return (0);
@@ -231,7 +240,8 @@
 	memset(&mbs, 0, sizeof(mbs));
 	while ((len = read(fd, buf, buf_size)) != 0) {
 		if (len == -1) {
-			warn("%s: read", file);
+            fprintf(thread_stderr, "wc: %s: read: %s\n", file, strerror(errno));
+            // warn("%s: read", file);
 			(void)close(fd);
 			return (1);
 		}
@@ -244,7 +254,8 @@
 			    (size_t)-1) {
 				if (!warned) {
 					errno = EILSEQ;
-					warn("%s", file);
+                    fprintf(thread_stderr, "wc: %s: %s\n", file, strerror(errno));
+                    // warn("%s", file);
 					warned = 1;
 				}
 				memset(&mbs, 0, sizeof(mbs));
@@ -269,18 +280,19 @@
 	}
 	if (domulti && MB_CUR_MAX > 1)
 		if (mbrtowc(NULL, NULL, 0, &mbs) == (size_t)-1 && !warned)
-			warn("%s", file);
+            fprintf(thread_stderr, "wc: %s: %s\n", file, strerror(errno));
+            // warn("%s", file);
 	if (doline) {
 		tlinect += linect;
-		(void)printf(" %7ju", linect);
+		(void)fprintf(thread_stdout, " %7ju", linect);
 	}
 	if (doword) {
 		twordct += wordct;
-		(void)printf(" %7ju", wordct);
+		(void)fprintf(thread_stdout, " %7ju", wordct);
 	}
 	if (dochar || domulti) {
 		tcharct += charct;
-		(void)printf(" %7ju", charct);
+		(void)fprintf(thread_stdout, " %7ju", charct);
 	}
 	(void)close(fd);
 	return (0);
@@ -289,6 +301,6 @@
 static void
 usage()
 {
-	(void)fprintf(stderr, "usage: wc [-clmw] [file ...]\n");
+	(void)fprintf(thread_stderr, "usage: wc [-clmw] [file ...]\n");
 	exit(1);
 }
