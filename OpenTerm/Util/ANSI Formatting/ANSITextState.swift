//
//  ANSITextState.swift
//  OpenTerm
//
//  Created by Ian McDowell on 1/31/18.
//  Copyright © 2018 Silver Fox. All rights reserved.
//

import UIKit

// 0-  7:  standard colors (as in ESC [ 30–37 m)
// 8- 15:  high intensity colors (as in ESC [ 90–97 m)
// 16-231:  6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)
// 232-255:  grayscale from black to white in 24 steps
private let colors: [(r:Int, g:Int, b:Int)] = [
    /* Normal colors */
    (0x00, 0x00, 0x00), /* Black   */
    (0x99, 0x3E, 0x3E), /* Red     */
    (0x3E, 0x99, 0x3E), /* Green   */
    (0x99, 0x99, 0x3E), /* Brown   */
    (0x3E, 0x3E, 0x99), /* Blue    */
    (0x99, 0x3E, 0x99), /* Magenta */
    (0x3E, 0x99, 0x99), /* Cyan    */
    (0x99, 0x99, 0x99), /* White   */

    /* Intense colors */
    (0x3E, 0x3E, 0x3E), /* Black   */
    (0xFF, 0x67, 0x67), /* Red     */
    (0x67, 0xFF, 0x67), /* Green   */
    (0xFF, 0xFF, 0x67), /* Brown   */
    (0x67, 0x67, 0xFF), /* Blue    */
    (0xFF, 0x67, 0xFF), /* Magenta */
    (0x67, 0xFF, 0xFF), /* Cyan    */
    (0xFF, 0xFF, 0xFF), /* White   */

    /* Additional colors (16-231) */
    (0x00, 0x00, 0x00),
    (0x00, 0x00, 0x5F),
    (0x00, 0x00, 0x87),
    (0x00, 0x00, 0xAF),
    (0x00, 0x00, 0xD7),
    (0x00, 0x00, 0xFF),
    (0x00, 0x5F, 0x00),
    (0x00, 0x5F, 0x5F),
    (0x00, 0x5F, 0x87),
    (0x00, 0x5F, 0xAF),
    (0x00, 0x5F, 0xD7),
    (0x00, 0x5F, 0xFF),
    (0x00, 0x87, 0x00),
    (0x00, 0x87, 0x5F),
    (0x00, 0x87, 0x87),
    (0x00, 0x87, 0xAF),
    (0x00, 0x87, 0xD7),
    (0x00, 0x87, 0xFF),
    (0x00, 0xAF, 0x00),
    (0x00, 0xAF, 0x5F),
    (0x00, 0xAF, 0x87),
    (0x00, 0xAF, 0xAF),
    (0x00, 0xAF, 0xD7),
    (0x00, 0xAF, 0xFF),
    (0x00, 0xD7, 0x00),
    (0x00, 0xD7, 0x5F),
    (0x00, 0xD7, 0x87),
    (0x00, 0xD7, 0xAF),
    (0x00, 0xD7, 0xD7),
    (0x00, 0xD7, 0xFF),
    (0x00, 0xFF, 0x00),
    (0x00, 0xFF, 0x5F),
    (0x00, 0xFF, 0x87),
    (0x00, 0xFF, 0xAF),
    (0x00, 0xFF, 0xD7),
    (0x00, 0xFF, 0xFF),
    (0x5F, 0x00, 0x00),
    (0x5F, 0x00, 0x5F),
    (0x5F, 0x00, 0x87),
    (0x5F, 0x00, 0xAF),
    (0x5F, 0x00, 0xD7),
    (0x5F, 0x00, 0xFF),
    (0x5F, 0x5F, 0x00),
    (0x5F, 0x5F, 0x5F),
    (0x5F, 0x5F, 0x87),
    (0x5F, 0x5F, 0xAF),
    (0x5F, 0x5F, 0xD7),
    (0x5F, 0x5F, 0xFF),
    (0x5F, 0x87, 0x00),
    (0x5F, 0x87, 0x5F),
    (0x5F, 0x87, 0x87),
    (0x5F, 0x87, 0xAF),
    (0x5F, 0x87, 0xD7),
    (0x5F, 0x87, 0xFF),
    (0x5F, 0xAF, 0x00),
    (0x5F, 0xAF, 0x5F),
    (0x5F, 0xAF, 0x87),
    (0x5F, 0xAF, 0xAF),
    (0x5F, 0xAF, 0xD7),
    (0x5F, 0xAF, 0xFF),
    (0x5F, 0xD7, 0x00),
    (0x5F, 0xD7, 0x5F),
    (0x5F, 0xD7, 0x87),
    (0x5F, 0xD7, 0xAF),
    (0x5F, 0xD7, 0xD7),
    (0x5F, 0xD7, 0xFF),
    (0x5F, 0xFF, 0x00),
    (0x5F, 0xFF, 0x5F),
    (0x5F, 0xFF, 0x87),
    (0x5F, 0xFF, 0xAF),
    (0x5F, 0xFF, 0xD7),
    (0x5F, 0xFF, 0xFF),
    (0x87, 0x00, 0x00),
    (0x87, 0x00, 0x5F),
    (0x87, 0x00, 0x87),
    (0x87, 0x00, 0xAF),
    (0x87, 0x00, 0xD7),
    (0x87, 0x00, 0xFF),
    (0x87, 0x5F, 0x00),
    (0x87, 0x5F, 0x5F),
    (0x87, 0x5F, 0x87),
    (0x87, 0x5F, 0xAF),
    (0x87, 0x5F, 0xD7),
    (0x87, 0x5F, 0xFF),
    (0x87, 0x87, 0x00),
    (0x87, 0x87, 0x5F),
    (0x87, 0x87, 0x87),
    (0x87, 0x87, 0xAF),
    (0x87, 0x87, 0xD7),
    (0x87, 0x87, 0xFF),
    (0x87, 0xAF, 0x00),
    (0x87, 0xAF, 0x5F),
    (0x87, 0xAF, 0x87),
    (0x87, 0xAF, 0xAF),
    (0x87, 0xAF, 0xD7),
    (0x87, 0xAF, 0xFF),
    (0x87, 0xD7, 0x00),
    (0x87, 0xD7, 0x5F),
    (0x87, 0xD7, 0x87),
    (0x87, 0xD7, 0xAF),
    (0x87, 0xD7, 0xD7),
    (0x87, 0xD7, 0xFF),
    (0x87, 0xFF, 0x00),
    (0x87, 0xFF, 0x5F),
    (0x87, 0xFF, 0x87),
    (0x87, 0xFF, 0xAF),
    (0x87, 0xFF, 0xD7),
    (0x87, 0xFF, 0xFF),
    (0xAF, 0x00, 0x00),
    (0xAF, 0x00, 0x5F),
    (0xAF, 0x00, 0x87),
    (0xAF, 0x00, 0xAF),
    (0xAF, 0x00, 0xD7),
    (0xAF, 0x00, 0xFF),
    (0xAF, 0x5F, 0x00),
    (0xAF, 0x5F, 0x5F),
    (0xAF, 0x5F, 0x87),
    (0xAF, 0x5F, 0xAF),
    (0xAF, 0x5F, 0xD7),
    (0xAF, 0x5F, 0xFF),
    (0xAF, 0x87, 0x00),
    (0xAF, 0x87, 0x5F),
    (0xAF, 0x87, 0x87),
    (0xAF, 0x87, 0xAF),
    (0xAF, 0x87, 0xD7),
    (0xAF, 0x87, 0xFF),
    (0xAF, 0xAF, 0x00),
    (0xAF, 0xAF, 0x5F),
    (0xAF, 0xAF, 0x87),
    (0xAF, 0xAF, 0xAF),
    (0xAF, 0xAF, 0xD7),
    (0xAF, 0xAF, 0xFF),
    (0xAF, 0xD7, 0x00),
    (0xAF, 0xD7, 0x5F),
    (0xAF, 0xD7, 0x87),
    (0xAF, 0xD7, 0xAF),
    (0xAF, 0xD7, 0xD7),
    (0xAF, 0xD7, 0xFF),
    (0xAF, 0xFF, 0x00),
    (0xAF, 0xFF, 0x5F),
    (0xAF, 0xFF, 0x87),
    (0xAF, 0xFF, 0xAF),
    (0xAF, 0xFF, 0xD7),
    (0xAF, 0xFF, 0xFF),
    (0xD7, 0x00, 0x00),
    (0xD7, 0x00, 0x5F),
    (0xD7, 0x00, 0x87),
    (0xD7, 0x00, 0xAF),
    (0xD7, 0x00, 0xD7),
    (0xD7, 0x00, 0xFF),
    (0xD7, 0x5F, 0x00),
    (0xD7, 0x5F, 0x5F),
    (0xD7, 0x5F, 0x87),
    (0xD7, 0x5F, 0xAF),
    (0xD7, 0x5F, 0xD7),
    (0xD7, 0x5F, 0xFF),
    (0xD7, 0x87, 0x00),
    (0xD7, 0x87, 0x5F),
    (0xD7, 0x87, 0x87),
    (0xD7, 0x87, 0xAF),
    (0xD7, 0x87, 0xD7),
    (0xD7, 0x87, 0xFF),
    (0xD7, 0xAF, 0x00),
    (0xD7, 0xAF, 0x5F),
    (0xD7, 0xAF, 0x87),
    (0xD7, 0xAF, 0xAF),
    (0xD7, 0xAF, 0xD7),
    (0xD7, 0xAF, 0xFF),
    (0xD7, 0xD7, 0x00),
    (0xD7, 0xD7, 0x5F),
    (0xD7, 0xD7, 0x87),
    (0xD7, 0xD7, 0xAF),
    (0xD7, 0xD7, 0xD7),
    (0xD7, 0xD7, 0xFF),
    (0xD7, 0xFF, 0x00),
    (0xD7, 0xFF, 0x5F),
    (0xD7, 0xFF, 0x87),
    (0xD7, 0xFF, 0xAF),
    (0xD7, 0xFF, 0xD7),
    (0xD7, 0xFF, 0xFF),
    (0xFF, 0x00, 0x00),
    (0xFF, 0x00, 0x5F),
    (0xFF, 0x00, 0x87),
    (0xFF, 0x00, 0xAF),
    (0xFF, 0x00, 0xD7),
    (0xFF, 0x00, 0xFF),
    (0xFF, 0x5F, 0x00),
    (0xFF, 0x5F, 0x5F),
    (0xFF, 0x5F, 0x87),
    (0xFF, 0x5F, 0xAF),
    (0xFF, 0x5F, 0xD7),
    (0xFF, 0x5F, 0xFF),
    (0xFF, 0x87, 0x00),
    (0xFF, 0x87, 0x5F),
    (0xFF, 0x87, 0x87),
    (0xFF, 0x87, 0xAF),
    (0xFF, 0x87, 0xD7),
    (0xFF, 0x87, 0xFF),
    (0xFF, 0xAF, 0x00),
    (0xFF, 0xAF, 0x5F),
    (0xFF, 0xAF, 0x87),
    (0xFF, 0xAF, 0xAF),
    (0xFF, 0xAF, 0xD7),
    (0xFF, 0xAF, 0xFF),
    (0xFF, 0xD7, 0x00),
    (0xFF, 0xD7, 0x5F),
    (0xFF, 0xD7, 0x87),
    (0xFF, 0xD7, 0xAF),
    (0xFF, 0xD7, 0xD7),
    (0xFF, 0xD7, 0xFF),
    (0xFF, 0xFF, 0x00),
    (0xFF, 0xFF, 0x5F),
    (0xFF, 0xFF, 0x87),
    (0xFF, 0xFF, 0xAF),
    (0xFF, 0xFF, 0xD7),
    (0xFF, 0xFF, 0xFF),

    /* greyscale (232-255) from black to white in 24 steps */
    (0x08, 0x08, 0x08),
    (0x12, 0x12, 0x12),
    (0x1C, 0x1C, 0x1C),
    (0x26, 0x26, 0x26),
    (0x30, 0x30, 0x30),
    (0x3A, 0x3A, 0x3A),
    (0x44, 0x44, 0x44),
    (0x4E, 0x4E, 0x4E),
    (0x58, 0x58, 0x58),
    (0x62, 0x62, 0x62),
    (0x6C, 0x6C, 0x6C),
    (0x76, 0x76, 0x76),
    (0x80, 0x80, 0x80),
    (0x8A, 0x8A, 0x8A),
    (0x94, 0x94, 0x94),
    (0x9E, 0x9E, 0x9E),
    (0xA8, 0xA8, 0xA8),
    (0xB2, 0xB2, 0xB2),
    (0xBC, 0xBC, 0xBC),
    (0xC6, 0xC6, 0xC6),
    (0xD0, 0xD0, 0xD0),
    (0xDA, 0xDA, 0xDA),
    (0xE4, 0xE4, 0xE4),
    (0xEE, 0xEE, 0xEE)
]

func indexedColor(atIndex index: Int) -> UIColor {
    guard index >= 0 && index <= 255 else { fatalError("Index out of bounds.") }
    let (r, g, b) = colors[index]
    return UIColor.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: 1)
}


func customColor(codes: [Int]) -> (color: UIColor, readCount: Int) {
    // Two supported cases:
    // - 5;n => 8-bit 0-255 color
    // - 2;r;g;b => RGB color
    let invalidResponse: (UIColor, Int) = (.clear, 0)

    switch codes.first ?? 0 {
    case 5:
        let expectedCodes = 2
        guard codes.count >= expectedCodes else { return invalidResponse }
        let value = codes[1]

        guard value <= 255 else { return invalidResponse }
        let color = indexedColor(atIndex: value)
        return (color, expectedCodes)
    case 2:
        let expectedCodes = 4
        guard codes.count >= expectedCodes else { return invalidResponse }
        let r = codes[1]
        let g = codes[2]
        let b = codes[3]
        let color = UIColor.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: 1)
        return (color, expectedCodes)
    default:
        return invalidResponse
    }
}

enum ANSIForegroundColor: Int {
    case `default` = 39
    case black = 30
    case red = 31
    case green = 32
    case yellow = 33
    case blue = 34
    case purple = 35
    case cyan = 36
    case white = 37

    // custom color (either 8-bit 0-255, or rgb)
    static let custom: Int = 38

    var color: UIColor {
        switch self {
        case .default: return UserDefaultsController.shared.terminalTextColor ?? .white
        default: return indexedColor(atIndex: self.rawValue - 30)
        }
    }
}

enum ANSIBackgroundColor: Int {
    case `default` = 49
    case black = 40
    case red = 41
    case green = 42
    case yellow = 43
    case blue = 44
    case purple = 45
    case cyan = 46
    case white = 47

    // custom color (either 8-bit 0-255, or rgb)
    static let custom: Int = 48

    var color: UIColor {
        switch self {
        case .default: return .clear
        default: return indexedColor(atIndex: self.rawValue - 40)
        }
    }
}

enum ANSIFontState: Int {
    case bold = 1
    case noBold = 21

    case faint = 2
    case noFaint = 22

    case italic = 3
    case noItalic = 23

    case underline = 4
    case noUnderline = 24

    case crossedOut = 9
    case noCrossedOut = 29
}

struct ANSITextState {
    var foregroundColor: UIColor = UserDefaultsController.shared.terminalTextColor ?? .white
    var backgroundColor: UIColor = UserDefaultsController.shared.terminalBackgroundColor ?? .black
    var isUnderlined: Bool = false
    var isStrikethrough: Bool = false
    var fontTraits: UIFontDescriptorSymbolicTraits = []

    var attributes: [NSAttributedStringKey: Any] {
        return [
            .foregroundColor: foregroundColor,
            .backgroundColor: backgroundColor,
            .underlineStyle: isUnderlined ? NSUnderlineStyle.styleSingle.rawValue : NSUnderlineStyle.styleNone.rawValue,
            .underlineColor: foregroundColor,
            .strikethroughStyle: isStrikethrough ? NSUnderlineStyle.styleSingle.rawValue : NSUnderlineStyle.styleNone.rawValue,
            .strikethroughColor: foregroundColor,
            .font: font
        ]
    }

    /// Get a font from the current state
    var font: UIFont {
        let textSize = CGFloat(UserDefaultsController.shared.terminalFontSize)
        var descriptor = UIFontDescriptor.init(name: "Menlo", size: textSize)
        if let traitDescriptor = descriptor.withSymbolicTraits(self.fontTraits) {
            descriptor = traitDescriptor
        }
        return UIFont.init(descriptor: descriptor, size: textSize)
    }

    mutating func reset() {
        foregroundColor = UserDefaultsController.shared.terminalTextColor ?? .white
        backgroundColor = UserDefaultsController.shared.terminalBackgroundColor ?? .black
        isUnderlined = false
        isStrikethrough = false
        fontTraits = []
    }

    mutating func parse(escapeCodes: String) {
        // Codes will be a colon-separated string of integers. For each one, adjust our state
        let codes = escapeCodes.components(separatedBy: ";").flatMap { Int($0) }
        var index = codes.startIndex
        while index < codes.endIndex {
            let code = codes[index]
            var readCount = 1

            // Reset code = reset all state
            if code == 0 { reset() }

            // Foreground color
            else if let foregroundColor = ANSIForegroundColor.init(rawValue: code) { self.foregroundColor = foregroundColor.color }
            else if code == ANSIForegroundColor.custom { let result = customColor(codes: Array(codes.suffix(from: index + 1))); readCount += result.readCount; foregroundColor = result.color }

            // Background color
            else if let backgroundColor = ANSIBackgroundColor.init(rawValue: code) { self.backgroundColor = backgroundColor.color }
            else if code == ANSIBackgroundColor.custom { let result = customColor(codes: Array(codes.suffix(from: index + 1))); readCount += result.readCount; backgroundColor = result.color }

            else if let fontState = ANSIFontState.init(rawValue: code) {
                switch fontState {
                case .bold: fontTraits.insert(.traitBold)
                case .noBold: fontTraits.remove(.traitBold)
                case .faint: break
                case .noFaint: break
                case .italic: fontTraits.insert(.traitItalic)
                case .noItalic: fontTraits.remove(.traitItalic)
                case .underline: isUnderlined = true
                case .noUnderline: isUnderlined = false
                case .crossedOut: isStrikethrough = true
                case .noCrossedOut: isStrikethrough = false
                }
            }

            index += readCount
        }
    }
}
